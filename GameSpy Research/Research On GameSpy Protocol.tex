\documentclass[oneside,titlepage,a4paper]{Definition/retrospy} %book,article,report,letter



\begin{document}

\title{\Huge\textbf{Research On GameSpy Protocol}} 
\author{Arves100, xiaojiuwo}


%\date{} %%如果没有这句，会生成时间

\maketitle  %%生成书名

\tableofcontents  %%生成目录

%\mainmatter %%表示文章的正文部分，在生成目录后将从第一页开始
\chapter{Introduction}

\section{The History of GameSpy}

\section{Related Works}


\chapter{General Information}
In this chapter we describe the structure of GameSpy SDK and GameSpy servers.
\section{SDK Module}
GameSpy SDK contains of  16 modules.
	\begin{itemize}
		\item Brigades
		\item Chat
		\item Presence \& Messaging
		\item CDKey
		\item Stats \& Tracking
		\item Persistent Storage
		\item Transport
		\item NAT Negotation
		\item Peer to Peer communication
		\item Patching \& Tracking
		\item Server Browser
		\item Query \& Reporting
		\item SAKE Persistent Storage
		\item ATLAS Competition
		\item Voice Chat
		\item Web Authentication
	\end{itemize}

\section{GameSpy Back-end Servers}
\par GameSpy back-end servers are list as follows.
	\begin{itemize}
		\item GameSpy Presence Connection Manager (GPCM)
		\item GameSpy Presence Search Player(GPSP)
		\item GameSpy Query and Report (QR)
		\item GameSpy Server Browser (SB)
		\item GameSpy Stats \& Tracking (GStats)
		\item GameSpy Chat
		\item GameSpy NAT Negotation (NatNeg)
		\item GameSpy CDKey 
		\item GameSpy Web Services
		\item GameSpy SAKE Storage (SAKE)
	\end{itemize}

\section{The Access Sequence of Client}
If a user want to use GameSpy service, the access sequence is listed in Figure~\ref{The access sequence of client} and we describe the detail below.
\begin{figure}[H]
	\centering
	\scalebox{0.7}{
	\begin{tikzpicture}  [node distance = 2cm, auto,transform shape]
	\node[block] (gpcm) {GPCM};
	%%%%%%%%%%%right nodes%%%%%%%%%%
	\node[block, right= of gpcm](gpsp){GPSP};
	\node[block, right= of gpsp](qr){QR};
	\node[block, below= of qr](sb){SB};
	%%%%%%%%%%%left nodes%%%%%%%%%%%
	\node[block,below= of gpcm](cdkey){CDKey};

		%%%%%%%%%%%bottom nodes%%%%%%%%
	\node[block, below= of gpsp] (client) {Client};  
	\node[block, below= of client](gstats){GSTATS};
	\node[block, right= of gstats](webserver){WebServer};
		\node[block, left= of gstats](chat){CHAT};
	%%%%%%%%%%%top nodes%%%%%%%%%%
	\node[block, above= of gpcm](gameserver){Game Server};
	
	
	%%%%%%%%%%%lines%%%%%%%%%%%%%
	\draw[line] (client)--node [midway, above, sloped] {\circled{\small{2}}}(gpcm);
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{2}}}(gpsp);
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{3}}}(cdkey);
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{4}}}(chat);
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{1}}} (qr);
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{7}}}(sb);
	
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{5}}}(gstats);
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{5}}}(webserver);
		
	\draw[line](sb)--(qr);
	
	\draw[line](gameserver)--node [midway, above, sloped] {\circled{\small{6}}}(qr);
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{8}}}(gameserver);
	\draw[line](gameserver.west) to [in=190,out=190] node [midway, above, sloped] {\circled{\small{9}}}(cdkey.west);


	\end{tikzpicture}  
}
	\caption{The access sequence of client}
	\label{The access sequence of client}
\end{figure}

\paragraph{Access sequence explain}
\begin{enumerate}
	\item Client access to available check in QR server, which tells client GameSpy back-end server status.
	\item Client access GPCM or GPSP to check their account and login.
	\item Client access to CDKey to verify his cd-key in login phase.
	\item Client login to Chat server.
	\item Client retrieve player data(level, exp, etc.) from GStats(old game use this server to store player data, new game use Web Server to store player data).
	\item When a game server is launched it will send heartbeat to QR server to tell QR its information.
	\item Client access to SB to search online game server.
	\item Client login to game server with his information and cd-key.
	\item Game server will check his cd-key by accessing to CDKey server, after every information is verified, client should be able to play their game.
\end{enumerate}


\section{Basic Description of Protocol}
In this part, we describe some of the basic patterns that are used in all GameSpy servers.

\subsection{The String Pattern}
We first introduce the pattern of the string, which is using to make up a request and response.
The following servers do use the pattern: Presence Connection Manager, Presence Search Player, GameSpy Status and Tracking, CD-Key, Query Report(version 1)
This kind of string represents a value in a request and response sent by the client or the server as Table \ref{String pattern}.\\


\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline 
		\textbf{String}&\textbf{Description}  \\ 
		\hline 
		$ \backslash key \backslash < value > \backslash $& The key is $ key $, the value of the key is $  value  $  \\ 
 		\hline
	\end{tabular} 
	\caption{String pattern}
	\label{String pattern}
\end{table}
There are two kind of patterns the first one is value string, the second one is command string.
\paragraph{Value String}
This kind of string represents a key value pair in the request or response string, it has a key and a correspond value as shown in Table~\ref{Value string}.
\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline 
		\textbf{String}&\textbf{Description}  \\ 
		\hline 
		$ \backslash pid \backslash  13  \backslash $& The key is $ pid $, the value of the $ pid $ is $  13  $  \\ 
		\hline
		$ \backslash userid \backslash  0  \backslash $& The key is $ userid $, the value of the $ userid $ is $  0  $  \\ 
		\hline
	\end{tabular} 
	\caption{Value string}
	\label{Value string}
\end{table}


\paragraph{Command String}

This kind of string represents a command in a request sends by the client or the server as Table \ref{Command string}.
The command will end with $ \backslash \backslash $ or $ \backslash $ depends on whether run at the server-side or client-side.


\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline 
		\textbf{String}&\textbf{Description}  \\ 
		\hline 
		$ \backslash command \backslash\backslash $& This is a command \\ 		
		\hline
	\end{tabular} 
	\caption{Command string}
	\label{Command string}
\end{table}


\chapter{GameSpy Presence \& Messaging}
\par Presence \& Messaging system allows a game to add account authentication or registration, which includes a profile where personal information could be stored (such as email, first name), a friend list (called buddies), private messages.
\par GameSpy Presence contains two server, GameSpy Presence Connection Manager (GPCM) and GameSpy Presence Search Player (GPSP).
GPCM is a server that manages the profiles (such as login, storing the profile information).

\section{Common Information}
In this section we describe the common information, methods, techniques that GPCM and GPSP have.
\subsection{Server IP and Ports}
Table \ref{IP and Ports for GameSpy Presence Servers} are the  IP and Ports of GPCM and GPSP that client or game connect to.
\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline 
		\textbf{Name}&\textbf{IP}&\textbf{Port}\\ 
		\hline 
		GPCM&gpcm.gamespy.com&29900 \\ 
	 	\hline 
		GPSP&gpsp.gamespy.com&29901 \\
		\hline
	\end{tabular} 
\caption{IP and Ports for GameSpy Presence Servers}
\label{IP and Ports for GameSpy Presence Servers}

\end{table}

\section{GameSpy Presence Connection Manager}


\subsection{Request For GameSpy Presence Connection Manager}
Table \ref{Request For GameSpy Presence Connection Manager} lists the request (known by us) that clients send to GameSpy Presence Connection Manager server (GPCM).
\begin{table}[H]
	\centering
	\begin{tabular}{B}
		\hline 
		\textbf{Commands}&\textbf{Description}  \\ 
		\hline 
		$\backslash inviteto \backslash$& Invite friends\\ 		
		\hline 
		$\backslash login \backslash$&Login to GPCM \\
		\hline
 		$\backslash getprofile \backslash$&	Get the profile of a player (including your own)\\
 		\hline
		$\backslash addbuddy \backslash$& Add a player to my friend list \\
		\hline
		$\backslash delbuddy \backslash$ & Delete a player from my friend list \\
		\hline
		$\backslash updateui \backslash$& Update login information (email, password) \\
		\hline
		$\backslash updatepro \backslash$& Update my profile such as first name, last name, gender etc. \\
		\hline
		$\backslash logout \backslash$& Logout manually by user\\
		\hline
		$\backslash status \backslash$& Update the status of a user (Such as what game is the player playing) \\
		\hline
		$\backslash ka \backslash$& Keep client or session alive \\ \hline
		$\backslash bm \backslash$& Message command \\
		\hline 
		$ \backslash blk \backslash $& Block list \\ \hline
		$ \backslash bdy \backslash $ & Friend list \\ \hline
		$ \backslash lt \backslash $& Login ticket \\ \hline
	\end{tabular} 
	\caption{Request For GameSpy Presence Connection Manager}
	\label{Request For GameSpy Presence Connection Manager}
\end{table}

Error response string for (GPCM, GPSP):
\begin{equation}
\begin{split}
\backslash error \backslash\backslash err \backslash < error code > \backslash fatal\backslash\backslash errmsg \backslash < error message > \backslash id\backslash 1 \backslash final \backslash
\end{split}	
\end{equation}
\subsection{Login Command $ \backslash login \backslash $}
We show the login communication diagram in Fig~\ref{Login diagram}
\begin{figure}[H]
	
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPCM};
		\draw[line] ([yshift=15]b.west)--node [fill = white] {1.Send server challenge} ([yshift=15]a.east);
		\draw[line] (a.east)--node [fill = white] {2.Send client challenge} (b.west);
		\draw[line] ([yshift=-15]b.west)--node [fill = white] {3.Accept or reject} ([yshift=-15]a.east);
		\end{tikzpicture}
	}
\caption{Login diagram}
\label{Login diagram}
\end{figure}

\myparagraph{1. Server initial Challenge}
When a client is connected to GPCM server, GPCM Server will send a challenge to client. The challenge string shows in \ref{server challenge1} and \ref{server challenge2}. However we do not know the correct functionality of \ref{server challenge2}.
\begin{tcolorbox}
	\begin{equation}\label{server challenge1}
	\begin{split}
	\backslash lc \backslash 1 \backslash challenge \backslash < > \backslash final \backslash
	\end{split}
	\end{equation}
\end{tcolorbox}
\begin{tcolorbox}
	\begin{equation}\label{server challenge2}
	\begin{split}
	\backslash lc \backslash 1 \backslash challenge \backslash < > 	\backslash nur \backslash\backslash userid \backslash < > \backslash profileid \backslash < > \backslash final \backslash
	\end{split}
	\end{equation}
\end{tcolorbox}

\begin{itemize}
	\item{challenge: }The challenge string sent by GPCM.
\end{itemize}
\begin{table}[H]
	\centering
	\begin{tabular}{A}
		
		\hline 
		\textbf{Keys}&\textbf{Description}&\textbf{Type}  \\ 
		\hline 
		challenge & The challenge string sended by GameSpy Presence server&String \\ 		
		\hline 
		nur & ? Create new user delimiter &\\
		\hline 
		userid&The userID of the profile & Uint\\	\hline 
		profileid&The profileID & Uint\\	\hline 
	\end{tabular} 
	\caption{The first type login response}
	\label{The first type login response}	
\end{table}	
\myparagraph{2. Client Login Challenge}
There are three ways of login:
\begin{itemize}
	\item AuthToken: Logging using an alphanumeric string that represents an user.
	\item 	UniqueNick: Logging using a nickname that is unique from all the players.
	\item User: Logging with nickname, email and password.
\end{itemize}
We show the common part of login request in \ref{Common string}
\begin{tcolorbox}
	\begin{equation}\label{Common string}
	\begin{split}
	&\backslash login \backslash \backslash challenge \backslash <  > \backslash \star
	\backslash userid \backslash <  > 
	\\& \backslash profileid \backslash <  > \backslash partnerid \backslash <  > \backslash response \backslash <  > 
	\\&
	\backslash firewall \backslash 1 \backslash port \backslash <  > \backslash productid \backslash  <  > 
	\\& \backslash gamename \backslash <  > \backslash namespaceid \backslash <  > 
	\\& \backslash  sdkrevision \backslash <  > \backslash quiet \backslash <  > \backslash id \backslash  \backslash final \backslash
	\end{split}
	\end{equation}
\end{tcolorbox}
Where the value of $ \star $ in \ref{Common string} depending on which login method user is using.
\begin{tcolorbox}
	\begin{equation}
		\begin{split}
		&\backslash authtoken \backslash <  > \backslash \\
		&\backslash uniquenick \backslash <  > \backslash\\
		&\backslash user \backslash <  > \backslash
		\end{split}
	\end{equation}
\end{tcolorbox}

\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline
		\textbf{Keys} & \textbf{Description} & \textbf{Type}	                                                                          \\ \hline
		login& The login command which use to identify the login request of client&\\ \hline
		challenge  & The user challenge used to verify the authenticity of the client     & See \ref{Login Proof Challenge Gerneration Algorithm}                                                                                                        \\ \hline
		authtoken  & The token used to login (represent of an user)        & String\\ \hline
		uniquenick  & The unique nickname used to login       & String                                                                                                                                                                 \\ \hline
		user     & The users account (format is NICKNAME@EMAIL)           &String\\ \hline
		userid    & User id              &      Uint                                                                                                                  \\ \hline
		profileid  & Profile id          &      Uint                                                                                                                  \\ \hline
		partnerid  & This ID is used to identify a backend service logged with gamespy.(Nintendo WIFI Connection will identify his partner as 11, which means that for gamespy, you are logging from a third party connection) & Uint\\ \hline
		response   & The client challenge used to verify the authenticity of the client     & String                                                                                                                                   \\ \hline
		firewall   & If this option is set to 1, then you are connecting under a firewall/limited connection & Uint\\
		\hline
		port& The peer port (used for p2p stuff)&Uint \\\hline
		productid  & An ID that identify the game you're using            &Uint\\ \hline
		gamename   & A string that rapresents the game that you're using, used also for several activities like peerchat server identification&string \\ \hline
		
		namespaceid & Distinguish same nickname player   &Uint                                                                                                                                                                                                     \\ \hline
		sdkrevision & The version of the SDK you're using&Uint \\ \hline
		quiet    & ? Maybe indicate invisible login which can not been seen at friends list & Uint\\ \hline
		lt& The login ticket used for login into SAKE&String \\ \hline
		id& The operation number&Uint\\ \hline
	\end{tabular} 
	\caption{Login parameter string}
	\label{Login parameter string}
\end{table}


\myparagraph{3. Server Response}

When received client's login request, server check the challenge and proof. if client pass the check, server will first send response\ref{server login response lc2} and then it will send friend list friend status, message, add friend request.
\begin{tcolorbox}
	\label{server login response lc2}
	\begin{equation}
	\begin{split}
	&\backslash lc \backslash 2 \backslash sesskey \backslash < > \backslash userid \backslash < > \backslash profileid \backslash < > \\
	&\backslash uniquenick \backslash < > \backslash lt \backslash < > \backslash proof \backslash < > \backslash final \backslash
	\end{split}
	\end{equation}
\end{tcolorbox}

\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline 
		\textbf{Keys}& \textbf{Description}&\textbf{Type}  \\ 
		\hline 
		sesskey & The session key, which is a integer rapresentating the client connection&Uint \\ 		
		\hline 
		userid & The userID of the profile&Uint \\
		\hline 
		profileid&The profileID &Uint\\	\hline 
		uniquenick&The logged in unique nick &String\\	\hline 
		lt& The login ticket, unknown usage&String\\\hline
		proof& The proof is something similar to the response but it vary&String\\\hline
	\end{tabular} 
	\caption{The second type login response}
	\label{The second type login response}
\end{table}
Proof in \ref*{The second type login response} generation: $ md5(password)||48 spaces $
The user could be AuthToken or the User/UniqueNick (with the extra PartnerID).
server challenge that we received before.
the client challenge that was generated before.

\subsection{SDK Revision}

\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Login Finished};  
		\node[block,below=20pt of a] (b) {SDKRevision Check};
		\node[block,below=20pt of b] (c) {Recv Buddy Message};
		\node[block,right=20pt of c] (d) {Recv Buddy Status Info};
		\node[block,right=20pt of b] (e) {Recv Buddy Request};
		\node[block,right=20pt of a] (f) {Recv Buddy Revoke};
		\node[block,right=20pt of f]  (g) {Recv Buddy List};
		\node[block,below=20pt of g] (h) {Recv Block List};

		\draw[line] (a.south)--(b.north);
		\draw[line] (b)--(c);
		\draw[line] (c)--(d);
		\draw[line] (d)--(e);
		\draw[line] (e)--(f);
		\draw[line] (f)--(g);
		\draw[line] (g)--(h);
\end{tikzpicture}
	}
	\caption{SDK Revision process}
	\label{SDK Revision process}
\end{figure}
	When a player finished login, GPCM will check his sdkrevision, sdkrevision is an addition of each sdkrevision number. Every addition of sdkrevision number will make GPCM act differently.
\begin{tcolorbox}
	\begin{itemize}
		\item Extended message support
		\begin{itemize}
			\item{1} GPI\_NEW\_AUTH\_NOTIFICATION = 1
			\item{2} GPI\_NEW\_REVOKE\_NOTIFICATION = 2
		\end{itemize}
		
		\item New Status Info support
		\begin{itemize}
			\item{4} define GPI\_NEW\_STATUS\_NOTIFICATION = 4
		\end{itemize}
		
		\item Buddy List + Block List retrieval on login
		\begin{itemize}
			\item{8} GPI\_NEW\_LIST\_RETRIEVAL\_ON\_LOGIN = 8
		\end{itemize}
	\item Remote Auth logins now return namespaceid/partnerid on login
	\begin{itemize}
		\item{16} GPI\_REMOTEAUTH\_IDS\_NOTIFICATION = 16
	\end{itemize}

	\item New CD Key registration style as opposed to using product ids
	\begin{itemize}
		\item{32}  GPI\_NEW\_CDKEY\_REGISTRATION = 32
	\end{itemize}

	\end{itemize}
\end{tcolorbox}

For now, we know the sdkrevision number of GameSpy SDK test and Crysis2.

\subsection{Buddy Message}
The Buddy Message is a method to transmit message, buddy add request, game invite, friend revoke(friend deletion), buddy status(online status etc.).
\begin{figure}[H]
	\centering
	\scalebox{0.7}{
		\begin{tikzpicture}
		\node[block] (a) {Buddy Message}; 
		

		\node[block, right= of a](Request) {Request};
		\node[block, above= of Request] (Message) {Message};
		\node[block, above= of Message](UTM) {UTM};
		
		
		\node[block, below= of Request](Status) {Status};
		\node[block, below= of Status](Auth) {Auth};
		

		\node[block, left= of a](Invite) {Invite};
		\node[block,above= of Invite](Revoke) {Revoke};
		\node[block,below= of Invite](Ping) {Ping};
		\node[block,below= of Ping](Pong) {Pong};
		
		\draw[line] (a.west)--(Invite);
		\draw[line] (a.east)|-(Request);
		
		\draw[line] (a.west)--+(-0.5,-0.0)|-(Revoke);
		\draw[line] (a.west)--+(-0.5,-0.0)|-(Ping);
		\draw[line] (a.west)--+(-0.5,-0.0)|-(Pong);
		
		\draw[line] (a.east)--+(+0.5,-0.0)|-(UTM);
		\draw[line] (a.east)--+(+0.5,-0.0)|-(Message);
		\draw[line] (a.east)--+(+0.5,-0.0)|-(Status);
		\draw[line] (a.east)--+(+0.5,-0.0)|-(Auth);
		\end{tikzpicture}
	}
	\caption{Buddy message module}
	\label{Buddy message module}
\end{figure}
When a Buddy Message received by a client, the client will determine Buddy Message type according to Table~\ref{Buddy Message Definition}.
\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|}
		\hline 
		\textbf{Definition}&\textbf{Value} \\ 
		\hline 
 GPI\_BM\_MESSAGE&            1\\\hline
 GPI\_BM\_REQUEST     &               2\\\hline
 GPI\_BM\_REPLY        &            3  \\\hline
 GPI\_BM\_AUTH        &             4\\\hline
 GPI\_BM\_UTM            &            5\\\hline
 GPI\_BM\_REVOKE      &               6 \\\hline
 GPI\_BM\_STATUS       &          100			\\\hline			
 GPI\_BM\_INVITE           &       101\\\hline
 GPI\_BM\_PING             &      102\\\hline
 GPI\_BM\_PONG           &          103\\\hline
 GPI\_BM\_KEYS\_REQUEST        &    104\\\hline
 GPI\_BM\_KEYS\_REPLY            &   105\\\hline
 GPI\_BM\_FILE\_SEND\_REQUEST   &  200\\\hline
 GPI\_BM\_FILE\_SEND\_REPLY      &   201\\\hline
 GPI\_BM\_FILE\_BEGIN       &      202\\\hline
 GPI\_BM\_FILE\_END             &   203\\\hline
 GPI\_BM\_FILE\_DATA             & 204\\\hline
 GPI\_BM\_FILE\_SKIP          &      205\\\hline
 GPI\_BM\_FILE\_TRANSFER\_THROTTLE   &206\\\hline
 GPI\_BM\_FILE\_TRANSFER\_CANCEL&     207\\\hline
 GPI\_BM\_FILE\_TRANSFER\_KEEPALIVE &208\\\hline
	\end{tabular} 
	\caption{Buddy Message Definition}
	\label{Buddy Message Definition}
\end{table}


\subsubsection{UTM}

\subsubsection{Buddy Revoke}


\subsubsection{Buddy Status}\label{Buddy Status}
This is an old method for game to get status information. buddy status \ref{Buddy Status} and buddy status info \ref{Buddy Status Info} can not be used at same time. Buddy status method is a part of Buddy Message module, old game send buddy status through a buddy message.


\subsection{Buddy Status Info}\label{Buddy Status Info}
This is a new method used in new game. \ref{Buddy Status} is an old method used in old game. Currently we can not tell you which game use new method and which use old method.
\begin{tcolorbox}\label{Buddy status info string}
	\begin{equation}
	\begin{split}
	&\backslash bsi \backslash \backslash state\backslash <buddy status> \backslash profile \backslash <profileid>  \\
	&\backslash bip \backslash <> \backslash bport \backslash <> \backslash hostip \backslash <> \backslash hprivip \backslash <> \\
	&\backslash qport \backslash <> \backslash hport \backslash <> \backslash sessflags \backslash <> \backslash rstatus \backslash <> \\
	& \backslash gameType \backslash <> \backslash  gameVnt \backslash <> \backslash gameMn \backslash <> \backslash product \backslash <> \\
	& \backslash qmodeflags \backslash <> \backslash final \backslash 
	\end{split}
	\end{equation}
\end{tcolorbox}

\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline 
		\textbf{Keys}& \textbf{Description}&\textbf{Type}  \\ 
		\hline 
		bsi & buddy status info command & \\ 		
		\hline 
		state & Buddy status state&Enum \\
		\hline 
		profileid&The profileID &Uint\\	\hline 
		bip& Buddy ip &String\\	\hline 
		bport&Buddy port&Uint\\\hline
		hostip& Host ip&String\\\hline
		hprivip&Host private ip&String\\\hline
		qport&Query port&Uint\\\hline
		hport&Host port&Uint\\\hline
		sessflags&Session flag&Uint\\\hline
		rstatus&Rich status ?&String\\\hline
		gameType&Game type&String\\\hline
		gameVnt&Game variant&String\\\hline
		gameMn&Game map name&String\\\hline
		product&Productid&uint\\\hline
		qmodeflags&Quiet mode flag&Enum\\\hline
	\end{tabular} 
	\caption{Buddy status info keys}
	\label{Buddy status info keys}
\end{table}

\subsection{Buddy List}
Buddy list is a list which contains your friends.
GPCM server will send buddy list when a client is logged in. Process is showing in Fig~\ref{Buddy List} and the response is showing in \ref{Buddy list string}.
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPCM};
		\draw[line] (b)--node [fill = white] {Send Buddy List} (a);
		\end{tikzpicture}
	}
	\caption{Buddy List}
	\label{Buddy List}
\end{figure}

\begin{tcolorbox}\label{Buddy list string}
	\begin{equation}
	\begin{split}
	&\backslash bdy \backslash < \text{number of profileid} > \backslash list \backslash \\ &<\text{profileid 1}>,<\text{profileid 2}>,\cdots,<\text{profileid n}>\\
	&\backslash final \backslash
	\end{split}
	\end{equation}
\end{tcolorbox}


\subsection{Block List}
Block list is an list which contain the players you do not like.
GPCM server will send block list when a client is logged in. Process is showing in Fig~\ref{Block List} and the response is showing in \ref{Block list string}.
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPCM};
		\draw[line] (b)--node [fill = white] {Send Block List} (a);
		\end{tikzpicture}
	}
	\caption{Block List}
	\label{Block List}
\end{figure}

\begin{tcolorbox}\label{Block list string}
	\begin{equation}
	\begin{split}
	&\backslash blk \backslash < \text{number of profileid} > \backslash list \backslash \\ &<\text{profileid 1}>,<\text{profileid 2}>,\cdots,<\text{profileid n}>\\
	&\backslash final \backslash
	\end{split}
	\end{equation}
\end{tcolorbox}


\section{GameSpy Presence Search Player}
Table \ref{IP and Ports for GameSpy Presence Servers} are the GPSP IP and Ports that client/game connect to.

\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPSP};
		\draw[line] ([yshift=8]a.east)--node [fill = white] {1.Send client search request} ([yshift=8]b.west);
		\draw[line] ([yshift=-8]b.west)--node [fill = white] {2.Send search result} ([yshift=-8]a.east);
		\end{tikzpicture}
	}
	\caption{GPSP diagram}
	\label{GPSP diagram}
\end{figure}

\subsection{Search User}
Client request \ref{Search User Request}.

\begin{tcolorbox}
	\begin{equation}\label{Search User Request}
	\begin{split}
	&\backslash search\backslash\backslash sesskey \backslash < >\backslash profileid \backslash < > \\ &\backslash namespaceid\backslash < >  \backslash partnerid\backslash < >\\
	& \backslash nick \backslash < > \backslash uniquenick \backslash < > \\ 
	&\backslash email \backslash < > \backslash gamename \backslash < > \backslash final \backslash
	\end{split}
	\end{equation}
\end{tcolorbox}

Server response \ref{Search user response}.

\begin{tcolorbox}
	\begin{equation}\label{Search user response}
	\begin{split}
&\backslash bsr \backslash < profileid > \backslash nick \backslash < nick > \backslash 
	\end{split}
	\end{equation}
\end{tcolorbox}

\subsubsection{User Creation}
This commmand \ref{Create user command} is used to create a user in GameSpy.
\begin{tcolorbox}
	\begin{equation}\label{Create user command}
	\begin{split}
	&\backslash newuser \backslash email \backslash < email > \backslash nick \backslash < nick > \\
	& \backslash passwordenc \backslash < passwordenc > 
	\backslash productid \backslash < productid > \\
	& \backslash gamename \backslash < gamename > \backslash uniquenick \backslash < uniquenick > \\
	& \backslash cdkeyenc \backslash < cdkeyenc > \backslash partnerid \backslash < partnerid > \backslash id \backslash 1 \backslash final \backslash
	\end{split}	
	\end{equation}
\end{tcolorbox}

The description of each parameter string is shown in Table \ref{User creation string}.
This is the response that server sends to client:
\begin{tcolorbox}
\begin{equation}
	\begin{split}
	&\backslash bsr \backslash <profileid> \backslash nick \backslash <nick>	\backslash uniquenick \backslash <uniquenick> \\
	&\backslash namespaceid \backslash <namespaceid>\backslash firstname \backslash <firstname> \\ 
	&\backslash lastname \backslash <lastname>\backslash email \backslash <email> \\
	&\backslash bsrdone \backslash <gamespy enc determinator> \backslash final \backslash
	\end{split}
\end{equation}
\end{tcolorbox}

\chapter{Persistent Storage}
\chapter{Transport}
\chapter{NAT Negotation}
Three matchup servers: natneg1. natnet2. natneg3.

IP: natneg1.gamespy.com or natneg2.gamespy.com or natneg3.gamespy.com
Protocol: UDP
Port: 27901

Nat Negotiation mechanism:
Because the ip address and other environment are changing from time to time, so when a client1 wants to connect
to client2, he dose not know any informations about client2, so he cannot connect to client2. using natneg it can ask client2 information on gamespy nat server and connect to client2.

The Nat Negotiation do the following things:
1.connect to GameSpy nat server
2.send the data that contain all information about himself to gamespy nat server
3.GameSpy Nat server store clients information.
4.when a client1 is try to connect to other client2:
(1) client1 send request to gamespy nat server
(2) gamespy nat server send the information about client2 to client1
(3) client1 get the client2 information and connect.

1. Client discovers if the servers are reachable
sends the following data

\begin{tcolorbox}
typedef struct \_InitPacket\\
\{\\
	unsigned char porttype;\\
	unsigned char clientindex;\\
	unsigned char usegameport;\\
	unsigned int localip;\\
	unsigned short localport;\\
\} InitPacket;\\

\#define REPORTPACKET\_SIZE BASEPACKET\_SIZE + 61\\
typedef struct \_ReportPacket\\
\{\\
	unsigned char porttype;\\
	unsigned char clientindex;\\
	unsigned char negResult;\\
	NatType natType;\\
	NatMappingScheme natMappingScheme;\\
	char gamename[50];\\
\} ReportPacket;\\

\#define CONNECTPACKET\_SIZE BASEPACKET\_SIZE + 8\\
typedef struct \_ConnectPacket\\
\{\\
	unsigned int remoteIP;\\
	unsigned short remotePort;\\
	unsigned char gotyourdata;\\
	unsigned char finished;\\
\} ConnectPacket;\\

\#define BASEPACKET\_SIZE 12\\
\#define BASEPACKET\_TYPE\_OFFSET 7\\
typedef struct \_NatNegPacket \\
\{\\
	// Base members:
	unsigned char magic[NATNEG\_MAGIC\_LEN];\\
	unsigned char version;\\
	unsigned char packettype;\\
	int cookie;	\\
	
	union \\
	\{\\
		InitPacket Init;\\
		ConnectPacket Connect;\\
		ReportPacket Report;\\
	\} Packet;\\
	
\} NatNegPacket;


\end{tcolorbox}





Magic: 0xFD 0xFC 0x1E 0x66 0x6A 0xB2
Version: 0x03

Command 1: Natify Request (0x12)
Cookie: htonl(777)

Sets Packet Init. portType to 1 if Natneg server is natneg1, 2 if it's natneg2, 3 if it's natneg3

Command 2: Address check (discover mapping)

Sets portType to as the same as Command 1
Cookie is htonl(0 for natneg1 (map1A), 1 for natneg2, 2 for natneg3, 3 for natneg1 second map (Map1B))

\chapter{Peer to Peer communication}
\chapter{Patching \& Tracking}
\chapter{Query \& Reporting}
Custom keys are used to define custom data to report, for example if the user is playing with a
Windows or Machintosh PC.

There could be two types of custom keys:
Player keys (they end with \_):
Custom player information
Team keys (they end with \_t):
Custom team (or brigade) information
Server keys (they don't end with anything):
Custom server information

Custom keys starts from 50 to 253


IP: gamename.master.gamespy.com
Port 27900
Protocol: UDP

There is more than one Query report ports, if 27900 is not found the system will 
try to scan the ports up to 28000

A dedicated server sends some information data to GameSpy Master Server to let GameSpy know
that a new server was started, so users can find the server in the server browser
like GameSpy 3D or GameSpy Arcade.

A server needs to be registred to GameSpy master Server, it's done with a challenge
Sending the heartbeat challenge packet and processing the response.
If an error happens, the AddError packet is sended.

A. Heartbeat (Only done if the server is public)
The heartbeat checks if the dedicated server is active or not.
When a dedicated servers sends a data, the time when the data is sended is saved in the Master server.
If the Master server does not receive a new data in 10 seconds, Master server removes the dedicated server
to the list and assumes the server is offline.

The dedicated server have to send the heartbeat packet each 10 seconds in order to maintain his connection
alive.

The Instance key is a random 4 bytes array characters generated by the client when it tries
to connect to the server

The heartbeat communicates everything new it happends to the server, like someone connected or similar.
\\
Keep alive packet:
A 5 bytes buffer composed by
0x08 (The packet id)
Instance key
\\
3 types of heartbeat packets
Type 3: Challenge heartbeat
Type 2: A server is shutting down
Type 1: User requested a change in the game data
Type 0: Normal heartbeat
\\
General heartbeat packet:

0x03 (The Packet ID)
Instance key
\\
A key represents the information of a data, much like a Dictionary (Similar to GPSP, but it uses $\backslash$0 rather than $\backslash\backslash$) 
\\
List of known keys:
localipX (Where X is the number of local IP starting from 0): Local IP of the server
localport: Query port binded by the server, where the Master Server can connect to
natneg: If you can nat negotiate with the server (If you do, the keep alive packet will also be sended)
statechanged: Integer (Type of heartbeat, see above)
gamename: Name of the game
\\
If the server want to track the local clients public ip, also this two extra parameters will be sended:
publicip: Public IP of the server
publicport: Public port
\\
The custom keys are now added with their respective value
Server, Player and Team
\\

NOTE: In the heartbeat, we are always querying the current known keys, so
rather than being "customkey\_one$\backslash$0customkey\_one\_data$\backslash$0" it's just "customkey\_one$\backslash$0$\backslash$0"
\\
(Each key is delimited by $\backslash$0)
\\
B. Check queries (Process any new query)
\\
We receive some data from the server.
\\
CD-Key query:
They start with 0x3B, nothing else is known
See CD-KEY Reverse for more information
\\
Query Report 1 queries (compatibility):
They start with $\backslash$
\\
Nat Negotiation query:
If the length is bigger than 6 and we find the NatNeg magic data
See NatNeg Reverse for more information
\\
Query Report 2:
If the first two bytes are 0xFE and 0xFD
\\
Query Report 2 Queries:
Structure:
Byte \[0\] = 0xFE
Byte \[1\] = 0xFD
Byte \[2\] = Packet type
Byte \[3-10\] = Request key (An array long 7 bytes)
\\
After all the queries are processed, the dedicated server sends back some data.
Which can be the challenges or something different.


Packet types:

Query (0x00)
This packet verify the IP of the client by checking if the random data
it was sended before (With 0x09) is the same. If it isn't the server won't
verify the client.

The dedicated server will send a notification to the Master Server about who
authenticated and who didn't

A character from the start of the data is called EXFlags and they are used to see if the QR2
server supports different things (an example is: Split if the server supports splitting the queries)

Maximum of 7 queries can be splitted

How a query is created:
A key called splitnum is created which contains the current number of key splitted
The key type (server, team or player)
The key data

Challenge (0x01)
This packet is used for verify the server with the master server.

Calculate the challenge:
First the backend option, each server can have some custom backend option, like disabling the Query Report challenge
The data sended is the following:

\[2 Bytes that are the backend option with a \backslash 0\] \\
\[Public IP (Length of 8, readed with htonl) and Port (length of 4)\]\\
\[ Max of 64 bytes containg a random data that will be the challenge, this is much like GPCM \]\\

Algorithm of calculating the challenge (Client side):

See qr2.c at line 785 (compue\_challenge\_response) for more information
A. Encrypt the challenge with the secret key
B. Encode the encrypted challenge

Echo (0x02)
Simply reply the same data as the server sended

The first byte is 0x05
Then the data the server sended (max 32 bytes are allowed)

Heartbeat (0x03)
Check "General heartbeat packet"

Add Error (0x04)
The master server sends an error to the dedicated server
For example about Server registration (Failed challenge)

Echo response (0x05)
This is a response of the Echo packet that Server sended to Client
Server to Client ID is 0x02, Client to Server ID is 0x05

Client Message (0x06)
Sends the following data (After the packet structure)

The first byte is 0x07 (Message ACK)
The other 4 bytes is the length of the message key

There can be sent a Nat negotiation packet now (With the natneg magic)
Or it can be a normam data

Max 10 messages to track

0x07???

Keep alive (0x08)
Ignored packet

Prequery IP Verify (0x09) [Server to Client only]
Try to verify the IP of a client that connects to the server.
This is only done if the user enable the IP challenge.
Each new client has to verify themself with a challenge.

A new key is added to the data to send:



%CD-Key/NatNeg authentication to QR2:
%Client ------> Query Report 2 ------> CD-Key/NatNeg Server -----> Query Report 2 (Filtered with CD-KEY or NatNeg Request) -----> Client

\chapter{Server Browser}
%UDP and ICMP sockets
%
%Connect to: ms<index>.gamespy.com:28910 (TCP)
%Where index is the index of the server, up to 20 multiple servers are supported.
%
%NOTE: Strings are null terminated
%
%Connect request:
%First three bytes: Message ID (0x00), length of the data (done with htons)
%Data:
%0x01 (Protocol version)
%0x03 (Encoding version)
%int32 (Unknown, should be 0, called queryFromVersion in the SDK)
%string[36] (Server returned for this game name)
%string[36] (The current game name)
%string[8] (Challenge)
%Server filter (char* with 0x0 at the end)
%Field list (char* with 0x0 at the end)
%int32 (Options, done with htonl)
%If we are using an alternative source ip:
%int32 (server IP with htonl)
%If we limit the results we can get
%int32 (max servers to see)
%
%
%Response is a Query Report 2 query:
%First byte is 0x00 for a normal response
%First byte is 0x09 for a challenge response
%
%From byte 2 to 5 there are some skipped bytes (Request key)
%
%If the client is expecting a Query Challenge, it sends a normal IP verify query (See QR2 research)
%Otherwise it sends a normal Query to QR2 with Split packets support
%It could request all keys or a basic query with not player or team queries and just some server queries
%
%
%When A client request a server:
%
%Request  :: Client (GameSpy 3D) -------> Server Browser (TCP 28910) --------> Query Report 2 Server (UDP 27901)
%Response :: Query Report 2 ------> Server Browser (Parse the QR2 data, filter it) -----> Client
%
%The server browser is like a high-level Query Report 2 server, it helps creating a server browser without having to
%do everything manually on the Query Report. An interpreter server for QR2.
%
%Get Server rules (Client request) from Server Browser server:
%First two bytes, htons(message length)
%Third byte: 0x01 (Server Info request)
%4 bytes: IP of server
%2 bytes: Port of server
%
%Send Message to the Server:
%First two bytes, htons(message length)
%Third byte: 0x02 (Send Message request)
%4 bytes: IP
%2 bytes: Port
%
%After this is done, the client sends the message (null terminated) to the Master Server (Server Browser server)
%
%Send NatNeg cookie to server:
%This just do a normal Send message to server function (see above)
%But the data is sended is a natneg request:
%First 6 bytes: NatNeg 6 magic (0xFD, 0xFC, 0x1E, 0x66, 0x6A, 0xB2)
%4 bytes for the cookie (htonl(cookie))
%
%
%Send MapLoop request:
%First two bytes, htons(message length)
%Third byte: 0x04 (MapLoop request)
%4 bytes: Public IP of server
%2 bytes: Public Port of server
%
%Send PlayerSearch request:
%First two bytes, htons(message length)
%Third byte: 0x05 (PlayerSearch request)
%4 bytes: Search option (htonl(searchOptions))
%4 bytes: Max result
%Null terminated string containing the name
%
%
%Server Browser responses:
%Main data (Or Server data):
%All data is crypted with GOA (Or Query Report 1 Server) algorithm for the cryptation key that is:
%Secret QR2 key + Challenge + Server Challenge		
%sb_serverlist.c line 797
%
%Data sended from server, header of crypted data:	
%[Length of Data] [Game Flags] [Data] [Length of Key] [Key Data]
%Byte 0: Length of the data (The length is XORed with 0xEC)
%Byte (Length of data - 1): Key length (Xored with 0xEA)
%The key data is used to decrypt the data
%Byte 1-2: Game flags (Setted by the dedicated server) and used htons
%The data is decrypted with GOA (QR1 Cryptation)
%
%Fixed Header (First 6 bytes of decrypted data):
%[Public IP] [Default port]
%PublicIP of the client requesting: 4 bytes
%Default port of the client requesting: 2 bytes (if it's 0xFFFF then there was an error)
%
%Error Data: It's contained after the fixed header to the end, null terminated
%Data:
%[Key List] [Unique Value List] [Server list]
%
%Key List:
%[Length of keys] [KeyInfo] [KeyInfo 2] [...]
%Length of keys: One byte (Max 255 Key infos)
%Key Info:
%[Key length] [Key Name] [Key Type]
%Key length: One byte
%Key name: Null terminated at the end
%
%Types of keys:
%0x01: KeyInfo byte (value length is 1)
%0x02: KeyInfo short (value length is 2)
%0x00: KeyInfo string
%The first byte is the index, if it's 0xFF then it's a null terminated string
%otherwise we already have the length when we parsed the keys
%
%
%Unique Value List:
%[Length of unique values] [Unique value] [Unique Value 2] [....]
%Length of uvalues: One byte (Max 255 unique values)
%Unique value: Null terminated string
%
%
%Server list:
%[Server Info] [Server Info 2] [...] [Last Server Info]
%
%Server Info:
%[Flags] [IP] [Port (Optional)] [Server Data (Optional)]
%Flags: One byte, if bit 5 of flags is setted (flags | 16), then the server does not use a default game port
%So, after the IP, The port data will be setted
%IP: 4 bytes containing the IP
%Port: 2 bytes
%
%Server Data:
%[Private IP] [Private Port] [ICMP IP] [KeyInfo...]
%If bit 2 of flags is setted, then we have the Private IP of the server
%The private IP length is 4
%
%If bit 6 is setted, the server uses a custom private port (not the default one)
%Private port length is 2
%
%If bit 4 is setted, the server have an ICMP server used
%ICMP IP length is 4
%
%If bit 7 is seteted, the server have some custom keys
%The length was setted when we where parsing the Key List data
%
%
%If bit 8 is setted, then we have the game full rules
%All the strings inside the full game rules are null terminated
%[Rule 1] [Rule 2] [...]
%
%
%Second data sended: AdHoc data (After the server/main data)
%This data is not crypted
%
%The first two byes is the message length (then htohs)
%The message can be at maximum 4096.
%
%The third byte is the message type
%Type 1: Push keys
%Add some keys to the server browser client
%The first character is the number of keys (max 255 keys)
%
%The keys follows the structure of KeyInfo
%
%Type 2: Server message
%Works the same as Server Info
%
%Type 3: Keepalive message
%All data the server sends it's replied back
%
%Type 4: Delete server
%[Server IP] [Server Port]
%Server IP: 4 bytes
%Server Port: 2 bytes (NOT OPTIONAL)
%
%Type 5: Maploop (Used when a new map needs to be selected)
%[Server IP] [Server Port] [Time] [Map Count] [Map Data] [Map Data 2...] [...]
%Server IP: 4 bytes
%Server Port: 2 bytes (NOT OPTIONAL)
%Time: 4 bytes (time_t)ntohl(time) rapresentation
%Map Count: One byte telling the number of maps avaiable
%Map Data: Null terminated string
%
%Type 6: Player Search
%[Is Final] [Result Count] [PlayerSearch Data] [PlayerSearch Data 2] [...]
%Is Final: 1 byte, when setted to 1, means the research is finished
%When setted to 0, the client have to expect another Type 6 adhoc packet
%Result Count: 1 byte telling the numbers of result that the playersearch produced
%
%PlayerSearch Data:
%[Nickname] [IP] [Port] [LastSeen] [Game name]
%Nickname: Null terminated string
%IP: 4 bytes
%Port: 2 bytes (not optional)
%Last Seen: 4 bytes, (time_t)ntohl(lastSeen)
%Game name: A null terminated string
%
%
%Get LAN server list:
%Client binds a socket that will be used for communicating with QR2 (Also multihomed support)
%Client sends a QR2 query request with ID 0x02 and 4 extra bytes (Called echo request) to Server Browser
%
%The QR2 socket is a broadcast socket
%
%When you create a  dedicated server in your lan, by using Query Report 2, GameSpy SB SDK discovers all
%dedicated servers opened in your network, if the dedicated servers reply the QR2 Echo Packet
%
%---------------------------------------------------- Master Server: ICMP -----------------------------
%
%Discovered with the SDK, we know that ICMP support can be disabled.
%It is confirmed to be used in platforms like PlayStation2.
%
%What server to connect?
%- If the Server (in the serverbrowser ServerData) define a custom ICMP IP, then connect to that
%- Otherwise, connect to the Public IP of the server
%
%Everything looks the same as ServerBrowsing reverse, the different seems to be that
%we can parse data not only from the Query socket (UDP) but from the ICMP socket
%
%Platforms that doesn't use ICMP:
%- Linux or any other Unix based distribution (like FreeBSD)
%- MacOSX
%- iPhone
%- Nintendo DS
%- Nintendo Wii
%
%The data follows a usual ICMP protocol: https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol
%Look at sb/sb_internal.h for more information about SBICMPHeader.
\chapter{SAKE Persistent Storage}
\chapter{ATLAS Competition}
\chapter{Voice Chat}
\chapter{Web Authentication}

\chapter{GameSpy Status \& Tracking}
when game connect to GSTATS server, server will send an message to game which contains the challenge, the total length of message must bigger than 38bytes, and the challenge must bigger than 20bytes.
when game received the challenge it will compute a response, the response is formed as follows. 
response = CRC32(<server challenge>,<length of server challenge>)||<game secret key>
then game will compute the MD5 hash as MD5value = MD5(<response>,<length of response>)
then encoded with Enctype3
then construct the challenge-response message as $ \backslash auth \backslash \backslash gamename \backslash <gamename>\backslash response \backslash <MD5value> \backslash port \backslash <port> \backslash id \backslash <id> $

session key length (unknown)
connction id = transfer ascii of sessionkey to integer

the initialization phase is finished.
server challenge message length (bigger than 38-byte)
server challenge length (bigger than 20-byte)
$ \backslash final \backslash $ is encrypted using XOR Enctype1 at the end of the challenge that sends by the server.


\begin{appendix}
\chapter{Login Proof Challenge Generation Algorithm}\label{Login Proof Challenge Gerneration Algorithm}
\chapter{Gstats Initial Encryption}
\chapter{CDKey Server Initial Encryption}
\end{appendix}


\end{document}
