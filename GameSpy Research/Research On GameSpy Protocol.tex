\documentclass[oneside,titlepage,a4paper]{Definition/retrospy} %book,article,report,letter



\begin{document}

\title{\Huge\textbf{Research On GameSpy Protocol}} 
\author{Arves100, xiaojiuwo}


%\date{} %%如果没有这句，会生成时间

\maketitle  %%生成书名

\tableofcontents  %%生成目录

%\mainmatter %%表示文章的正文部分，在生成目录后将从第一页开始
\part{Introduction}

\chapter{History of GameSpy}

\chapter{Related Works}


\part{General Information}
In this chapter we describe the structure of GameSpy SDK and GameSpy servers.
\chapter{SDK Module}
GameSpy SDK contains of  16 modules.
	\begin{itemize}
		\item Brigades
		\item Chat
		\item Presence \& Messaging
		\item CDKey
		\item Stats \& Tracking
		\item Persistent Storage
		\item Transport
		\item NAT Negotation
		\item Peer to Peer communication
		\item Patching \& Tracking
		\item Server Browser
		\item Query \& Reporting
		\item SAKE Persistent Storage
		\item ATLAS Competition
		\item Voice Chat
		\item Web Authentication
	\end{itemize}

\chapter{GameSpy Back-end Servers}
\par GameSpy back-end servers are list as follows.
	\begin{itemize}
		\item GameSpy Presence Connection Manager (GPCM)
		\item GameSpy Presence Search Player(GPSP)
		\item GameSpy Query and Report (QR)
		\item GameSpy Server Browser (SB)
		\item GameSpy Stats \& Tracking (GStats)
		\item GameSpy Chat
		\item GameSpy NAT Negotation (NatNeg)
		\item GameSpy CDKey 
		\item GameSpy Web Services
		\item GameSpy SAKE Storage (SAKE)
	\end{itemize}

\chapter{Access Sequence of The Client}
If a user want to use GameSpy service, the access sequence is listed in Figure~\ref{The access sequence of client} and we describe the detail below.
\begin{figure}[H]
	\centering
	\scalebox{0.7}{
	\begin{tikzpicture}  [node distance = 2cm, auto,transform shape]
	\node[block] (gpcm) {GPCM};
	%%%%%%%%%%%right nodes%%%%%%%%%%
	\node[block, right= of gpcm](gpsp){GPSP};
	\node[block, right= of gpsp](qr){QR};
	\node[block, below= of qr](sb){SB};
	%%%%%%%%%%%left nodes%%%%%%%%%%%
	\node[block,below= of gpcm](cdkey){CDKey};

		%%%%%%%%%%%bottom nodes%%%%%%%%
	\node[block, below= of gpsp] (client) {Client};  
	\node[block, below= of client](gstats){GSTATS};
	\node[block, right= of gstats](webserver){WebServer};
		\node[block, left= of gstats](chat){CHAT};
	%%%%%%%%%%%top nodes%%%%%%%%%%
	\node[block, above= of gpcm](gameserver){Game Server};
	
	
	%%%%%%%%%%%lines%%%%%%%%%%%%%
	\draw[line] (client)--node [midway, above] {\circled{\small{2}}}(gpcm);
	\draw[line](client)--node [midway, left] {\circled{\small{2}}}(gpsp);
	\draw[line](client)--node [midway, above] {\circled{\small{3}}}(cdkey);
	\draw[line](client)--node [midway, above] {\circled{\small{4}}}(chat);
	\draw[line](client)--node [midway, above] {\circled{\small{1}}} (qr);
	\draw[line](client)--node [midway, above] {\circled{\small{7}}}(sb);
	
	\draw[line](client)--node [midway, left] {\circled{\small{5}}}(gstats);
	\draw[line](client)--node [midway, above] {\circled{\small{5}}}(webserver);
		
	\draw[line](sb)--(qr);
	
	\draw[line](gameserver)--node [midway, above] {\circled{\small{6}}}(qr);
	\draw[line](client)--node [midway, right] {\circled{\small{8}}}(gameserver);
	\draw[line](gameserver.west) to [in=190,out=190] node [midway, right] {\circled{\small{9}}}(cdkey.west);


	\end{tikzpicture}  
}
	\caption{The access sequence of client}
	\label{The access sequence of client}
\end{figure}
\begin{flushleft}
\textbf{Explanation of access sequence}
\end{flushleft}

\begin{enumerate}
	\item Client checks in QR server, which tells client GameSpy back-end server status.
	\item Client accesses GPCM or GPSP to check their account and login.
	\item Client accesses to CDKey to verify his cd-key in login phase.
	\item Client logins to Chat server.
	\item Client retrieves player data(level, exp, etc.) from GStats(old game use this server to store player data, new game use Web Server to store player data).
	\item When a game server is launched it will send heartbeat to QR server to tell QR its information.
	\item Client accesses to SB to search online game server.
	\item Client logins to game server with his information and cd-key.
	\item Game server will check his cd-key by accessing to CDKey server, after every information is verified, client should be able to play their game.
\end{enumerate}


\chapter{Basic Description of Protocol}
In this part, we describe some of the basic patterns that are used in all GameSpy servers.

\section{String Pattern}
We first introduce the pattern of the string, which is used to make up a request and response.
The following servers do use the pattern: Presence Connection Manager, Presence Search Player, GameSpy Status and Tracking, CD-Key, Query Report(version 1)
This kind of string represents a value in a request and response sent by the client or the server as Table \ref{String pattern}.\\


\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline 
		\textbf{String}&\textbf{Description}  \\ 
		\hline 
		\tbs \textbf{key}\tbs\textbf{value}\tbs& The key is \textbf{key}, the value of the key is \textbf{value}  \\ 
 		\hline
	\end{tabular} 
	\caption{String pattern}
	\label{String pattern}
\end{table}
There are two kind of patterns the first one is value string, the second one is command string.
\textbf{Value String}
This kind of string represents a key value pair in the request or response string, it has a key and a correspond value as shown in Table~\ref{Value string}.
\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline 
		\textbf{String}&\textbf{Description}  \\ 
		\hline 
		\tbs pid\tbs  13\tbs & The key is \textbf{pid}, the value of the \textbf{pid} is 13  \\ 
		\hline
		\tbs userid\tbs  0\tbs & The key is \textbf{userid}, the value of the  \textbf{userid} is 0  \\ 
		\hline
	\end{tabular} 
	\caption{Value string}
	\label{Value string}
\end{table}


\textbf{Command String}

This kind of string represents a command in a request sends by the client or the server as Table \ref{Command string}.
The command will end with $ \backslash \backslash $ or $ \backslash $ depends on whether run at the server-side or client-side.


\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline 
		\textbf{String}&\textbf{Description}  \\ 
		\hline 
		\tbs command\tbs\tbs& This is a command \\ 		
		\hline
	\end{tabular} 
	\caption{Command string}
	\label{Command string}
\end{table}


\part{GameSpy Presence \& Messaging}
\par Presence \& Messaging system allows a game to add account authentication or registration, which includes a profile where personal information could be stored (such as email, first name), a friend list (called buddies), private messages.
\par GameSpy Presence contains two servers, GameSpy Presence Connection Manager (GPCM) and GameSpy Presence Search Player (GPSP).
GPCM is a server that manages the profiles (such as login, storing the profile information).

\chapter{Common Information}
In this section we describe the common information, methods, techniques that GPCM and GPSP have.
\section{Server IP and Ports}
Table \ref{IP and Ports for GameSpy Presence Servers} are the  IP and Ports of GPCM and GPSP that client or game connect to.
\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline 
		\textbf{Name}&\textbf{IP}&\textbf{Port}\\ 
		\hline 
		GPCM&gpcm.gamespy.com&29900 (tcp) \\ 
	 	\hline 
		GPSP&gpsp.gamespy.com&29901 (tcp)\\
		\hline
	\end{tabular} 
\caption{IP and Ports for GameSpy Presence Servers}
\label{IP and Ports for GameSpy Presence Servers}

\end{table}

\chapter{GameSpy Presence Connection Manager}


\section{Request Command of GameSpy Presence Connection Manager}
Table \ref{Request For GameSpy Presence Connection Manager} lists the request (known by us) that clients send to GameSpy Presence Connection Manager server (GPCM).
\begin{table}[H]
	\centering
	\begin{tabular}{B}
		\hline 
		\textbf{Commands}&\textbf{Description}  \\ 
		\hline 
		 inviteto& Invite friends\\ 		
		\hline 
		 login &Login to GPCM \\
		\hline
 		 getprofile &	Get the profile of a player (including your own)\\
 		\hline
		 addbuddy & Add a player to my friend list \\
		\hline
		delbuddy  & Delete a player from my friend list \\
		\hline
		updateui & Update login information (email, password) \\
		\hline
		updatepro & Update my profile such as first name, last name, gender etc. \\
		\hline
		 logout & Logout manually by user\\
		\hline
		status& Update the status of a user (Such as what game is the player playing) \\
		\hline
		ka & Keep client or session alive \\ \hline
		 bm & Message command \\
		\hline 
		 blk & Block list \\ \hline
		bdy  & Friend list \\ \hline
		 lt & Login ticket \\ \hline
	\end{tabular} 
	\caption{Request For GameSpy Presence Connection Manager}
	\label{Request For GameSpy Presence Connection Manager}
\end{table}

Error response string for (GPCM, GPSP):
\begin{equation}
\begin{split}
\backslash error \backslash\backslash err \backslash < error code > \backslash fatal\backslash\backslash errmsg \backslash < error message > \backslash id\backslash 1 \backslash final \backslash
\end{split}	
\end{equation}

\section{GPI Connect Module}
\subsection{Login}
We show the login communication diagram in Fig~\ref{Login diagram}
\begin{figure}[H]
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPCM};
		\draw[line] ([yshift=15]b.west)--node [fill = white] {1.Send server challenge} ([yshift=15]a.east);
		\draw[line] (a.east)--node [fill = white] {2.Send client request} (b.west);
		\draw[line] ([yshift=-15]b.west)--node [fill = white] {3.Accept or reject} ([yshift=-15]a.east);
		\end{tikzpicture}
	}
\caption{Login diagram}
\label{Login diagram}
\end{figure}

\begin{flushleft}
	\textbf{Server initial Challenge:\\}
\end{flushleft}
When a client is connected to GPCM server, GPCM Server will send a challenge to client. The challenge string shows in \ref{server challenge1} and \ref{server challenge2}. However we do not know the correct functionality of \ref{server challenge2}.

\begin{mybox}[label=server challenge1]
	\tbs lc\tbs 1\tbs challenge\tbs<challenge string>\tbs final\tbs
\end{mybox}

\begin{mybox}[label=server challenge2]
	\tbs lc\tbs 1\tbs challenge\tbs<challenge string>\tbs nur\tbs\tbs userid\tbs<user id>\\
	\tbs profileid\tbs<profile id>\tbs final\tbs
\end{mybox}

\begin{itemize}
	\item{challenge: }The challenge string sent by GPCM.
\end{itemize}
\begin{table}[H]
	\centering
	\begin{tabular}{A}
		
		\hline 
		\textbf{Keys}&\textbf{Description}&\textbf{Type}  \\ 
		\hline 
		challenge & The challenge string sended by GameSpy Presence server&String \\ 		
		\hline 
		nur & ? Create new user delimiter &\\
		\hline 
		userid&The userID of the profile & Uint\\	\hline 
		profileid&The profileID & Uint\\	\hline 
	\end{tabular} 
	\caption{The first type login response}
	\label{The first type login response}	
\end{table}	

\begin{flushleft}
	\textbf{Client Login Request:\\}
\end{flushleft}
There are three ways of login:
\begin{itemize}
	\item AuthToken: Logging using an alphanumeric string that represents an user.
	\item 	UniqueNick: Logging using a nickname that is unique from all the players.
	\item User: Logging with nickname, email and password.
\end{itemize}
We show the common part of login request in \ref{Common string}

\begin{mybox}[label=Common string]
	\tbs login\tbs\tbs challenge\tbs<challenge string>\tbs $\star$\tbs userid\tbs<user id>\\
	\tbs profileid\tbs <profile id>\tbs partnerid\tbs<partner id>\\
	\tbs response\tbs<challenge response string>\tbs firewall\tbs<firewall flag>\\\tbs port\tbs<port>\tbs productid\tbs<product id>\tbs gamename\tbs<game name>\\\tbs sdkrevision\tbs<sdk revision number>\tbs quiet\tbs<quiet mode flag>\\\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}

Where the value of $ \star $ in \ref{Common string} depending on which login method user is using.

\begin{mybox}
	\tbs authtoken\tbs<authentication token>\tbs\\
	\tbs uniquenick\tbs<uniquenick name>\tbs\\
	\tbs user\tbs<nick name+@+email>\tbs
\end{mybox}
\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline
		\textbf{Keys} & \textbf{Description} & \textbf{Type}	                                                                          \\ \hline
		login& The login command which use to identify the login request of client&\\ \hline
		challenge  & The user challenge used to verify the authenticity of the client     & See \ref{Login Proof Challenge Gerneration Algorithm}                                                                                                        \\ \hline
		authtoken  & The token used to login (represent of an user)        & String\\ \hline
		uniquenick  & The unique nickname used to login       & String                                                                                                                                                                 \\ \hline
		user     & The users account (format is NICKNAME@EMAIL)           &String\\ \hline
		userid    & User id              &      Uint                                                                                                                  \\ \hline
		profileid  & Profile id          &      Uint                                                                                                                  \\ \hline
		partnerid  & This ID is used to identify a backend service logged with gamespy.(Nintendo WIFI Connection will identify his partner as 11, which means that for gamespy, you are logging from a third party connection) & Uint\\ \hline
		response   & The client challenge used to verify the authenticity of the client     & String                                                                                                                                   \\ \hline
		firewall   & If this option is set to 1, then you are connecting under a firewall/limited connection & Uint\\
		\hline
		port& The peer port (used for p2p stuff)&Uint \\\hline
		productid  & An ID that identify the game you're using            &Uint\\ \hline
		gamename   & A string that rapresents the game that you're using, used also for several activities like peerchat server identification&string \\ \hline
		
		namespaceid & Distinguish same nickname player   &Uint                                                                                                                                                                                                     \\ \hline
		sdkrevision & The version of the SDK you're using&Uint \\ \hline
		quiet    & ? Maybe indicate invisible login which can not been seen at friends list & Uint\\ \hline
		lt& The login ticket used for login into SAKE&String \\ \hline
		id& The operation number&Uint\\ \hline
	\end{tabular} 
	\caption{Login parameter string}
	\label{Login parameter string}
\end{table}


\ServerResponse

When received client's login request, server check the challenge and proof. if client pass the check, server will first send response\ref{server login response lc2} and then it will send friend list friend status, message, add friend request.

\begin{mybox}[label=server login response lc2]
	\tbs lc\tbs 2\tbs sesskey\tbs<session key>\tbs userid\tbs<user id>\tbs uniquenick\tbs <unique nick>\tbs lt\tbs<login ticket>\tbs<challenge proof>\tbs final\tbs
\end{mybox}

\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline 
		\textbf{Keys}& \textbf{Description}&\textbf{Type}  \\ 
		\hline 
		sesskey & The session key, which is a integer rapresentating the client connection&Uint \\ 		
		\hline 
		userid & The userID of the profile&Uint \\
		\hline 
		profileid&The profileID &Uint\\	\hline 
		uniquenick&The logged in unique nick &String\\	\hline 
		lt& The login ticket, unknown usage&String\\\hline
		proof& The proof is something similar to the response but it vary&String\\\hline
	\end{tabular} 
	\caption{The second type login response}
	\label{The second type login response}
\end{table}
Proof in \ref*{The second type login response} generation: $ md5(password)||48 spaces $
The user could be AuthToken or the User/UniqueNick (with the extra PartnerID).
server challenge that we received before.
the client challenge that was generated before.

\subsection{SDK Revision}

\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Login Finished};  
		\node[block,below=20pt of a] (b) {SDKRevision Check};
		\node[block,below=20pt of b] (c) {Recv Buddy Message};
		\node[block,right=20pt of c] (d) {Recv Buddy Status Info};
		\node[block,right=20pt of b] (e) {Recv Buddy Request};
		\node[block,right=20pt of a] (f) {Recv Buddy Revoke};
		\node[block,right=20pt of f]  (g) {Recv Buddy List};
		\node[block,below=20pt of g] (h) {Recv Block List};

		\draw[line] (a.south)--(b.north);
		\draw[line] (b)--(c);
		\draw[line] (c)--(d);
		\draw[line] (d)--(e);
		\draw[line] (e)--(f);
		\draw[line] (f)--(g);
		\draw[line] (g)--(h);
\end{tikzpicture}
	}
	\caption{SDK Revision process}
	\label{SDK Revision process}
\end{figure}
	When a player finished login, GPCM will check his sdkrevision, sdkrevision is an addition of each sdkrevision number. Every addition of sdkrevision number will make GPCM act differently.
\begin{mybox}
	\begin{itemize}
		\item Extended message support
		\begin{itemize}
			\item{1} GPI\_NEW\_AUTH\_NOTIFICATION = 1
			\item{2} GPI\_NEW\_REVOKE\_NOTIFICATION = 2
		\end{itemize}
		
		\item New Status Info support
		\begin{itemize}
			\item{4} define GPI\_NEW\_STATUS\_NOTIFICATION = 4
		\end{itemize}
		
		\item Buddy List + Block List retrieval on login
		\begin{itemize}
			\item{8} GPI\_NEW\_LIST\_RETRIEVAL\_ON\_LOGIN = 8
		\end{itemize}
	\item Remote Auth logins now return namespaceid/partnerid on login
	\begin{itemize}
		\item{16} GPI\_REMOTEAUTH\_IDS\_NOTIFICATION = 16
	\end{itemize}

	\item New CD Key registration style as opposed to using product ids
	\begin{itemize}
		\item{32}  GPI\_NEW\_CDKEY\_REGISTRATION = 32
	\end{itemize}

	\end{itemize}
\end{mybox}

For now, we know the sdkrevision number of GameSpy SDK test and Crysis2.


\section{GPI Buddy Module}
\subsection{Buddy Message}
The Buddy Message is a method to transmit message, buddy add request, game invite, friend revoke(friend deletion), buddy status(online status etc.).
\begin{figure}[H]
	\centering
	\scalebox{0.7}{
		\begin{tikzpicture}
		\node[block] (a) {Buddy Message}; 
		

		\node[block, right= of a](Request) {Request};
		\node[block, above= of Request] (Message) {Message};
		\node[block, above= of Message](UTM) {UTM};
		
		
		\node[block, below= of Request](Status) {Status};
		\node[block, below= of Status](Auth) {Auth};
		

		\node[block, left= of a](Invite) {Invite};
		\node[block,above= of Invite](Revoke) {Revoke};
		\node[block,below= of Invite](Ping) {Ping};
		\node[block,below= of Ping](Pong) {Pong};
		
		\draw[line] (a.west)--(Invite);
		\draw[line] (a.east)|-(Request);
		
		\draw[line] (a.west)--+(-0.5,-0.0)|-(Revoke);
		\draw[line] (a.west)--+(-0.5,-0.0)|-(Ping);
		\draw[line] (a.west)--+(-0.5,-0.0)|-(Pong);
		
		\draw[line] (a.east)--+(+0.5,-0.0)|-(UTM);
		\draw[line] (a.east)--+(+0.5,-0.0)|-(Message);
		\draw[line] (a.east)--+(+0.5,-0.0)|-(Status);
		\draw[line] (a.east)--+(+0.5,-0.0)|-(Auth);
		\end{tikzpicture}
	}
	\caption{Buddy message module}
	\label{Buddy message module}
\end{figure}
When a Buddy Message received by a client, the client will determine Buddy Message type according to Table~\ref{Buddy Message Definition}.
\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|}
		\hline 
		\textbf{Definition}&\textbf{Value} \\ 
		\hline 
 GPI\_BM\_MESSAGE&            1\\\hline
 GPI\_BM\_REQUEST     &               2\\\hline
 GPI\_BM\_REPLY        &            3  \\\hline
 GPI\_BM\_AUTH        &             4\\\hline
 GPI\_BM\_UTM            &            5\\\hline
 GPI\_BM\_REVOKE      &               6 \\\hline
 GPI\_BM\_STATUS       &          100			\\\hline			
 GPI\_BM\_INVITE           &       101\\\hline
 GPI\_BM\_PING             &      102\\\hline
 GPI\_BM\_PONG           &          103\\\hline
 GPI\_BM\_KEYS\_REQUEST        &    104\\\hline
 GPI\_BM\_KEYS\_REPLY            &   105\\\hline
 GPI\_BM\_FILE\_SEND\_REQUEST   &  200\\\hline
 GPI\_BM\_FILE\_SEND\_REPLY      &   201\\\hline
 GPI\_BM\_FILE\_BEGIN       &      202\\\hline
 GPI\_BM\_FILE\_END             &   203\\\hline
 GPI\_BM\_FILE\_DATA             & 204\\\hline
 GPI\_BM\_FILE\_SKIP          &      205\\\hline
 GPI\_BM\_FILE\_TRANSFER\_THROTTLE   &206\\\hline
 GPI\_BM\_FILE\_TRANSFER\_CANCEL&     207\\\hline
 GPI\_BM\_FILE\_TRANSFER\_KEEPALIVE &208\\\hline
	\end{tabular} 
	\caption{Buddy Message Definition}
	\label{Buddy Message Definition}
\end{table}
Because Client1 and Client2 are in NAT network, so they can not connect each other using p2p, so GPCM will forward message for them. The forward diagram shows in Figure~\ref{Buddy message diagram}
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client1};  
		\node[block,right=200pt of a] (b) {GPCM};
		\node[block,below= of a] (c) {Client2};
		\draw[line] (a)--node [fill = white] {Client buddy message} (b);
		\draw[line] (b)|-node [fill=white] {Server buddy message} (c);
		\end{tikzpicture}
	}
	\caption{Buddy message diagram}
	\label{Buddy message diagram}
\end{figure}
All Buddy Message from Client will have same prefix which we show in \ref{Client buddy message prefix}
\ClientRequest

\begin{mybox}[label=Client buddy message prefix]
	\tbs bm\tbs <buddy message type>\tbs sesskey\tbs <session key>\\
	\tbs t\tbs<profile id>\tbs date\tbs<date>\tbs$ \cdots $\tbs final\tbs
\end{mybox}



\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline 
		\textbf{Keys}& \textbf{Description}&\textbf{Type}  \\ 
		\hline 
		bm & Indicate the buddy message command, please see \ref{Buddy Message Definition}&Uint \\ 		
		\hline 
		t & Profileid of the receiver&Uint \\
		\hline 
		sesskey&The session key of the sender client&Uint\\	\hline
		msg& The message contents& String\\\hline 
	\end{tabular} 
	\caption{Client buddy message command in prefix}
	\label{Client buddy message command in prefix}
\end{table}



All Buddy Message from GPCM will have same prefix which we show in \ref{Buddy message prefix}. The contents in $ \cdots $ is different from each Buddy Message Type.
\ServerResponse

\begin{mybox}[label=Buddy message prefix]
	\tbs bm\tbs <buddy message type>\tbs f\tbs<profile id>\tbs date\tbs<date>\tbs$ \cdots $\tbs final\tbs
\end{mybox}

\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline 
		\textbf{Keys}& \textbf{Description}&\textbf{Type}  \\ 
		\hline 
		bm & Indicate the buddy message command, please see \ref{Buddy Message Definition}&Uint \\ 		
		\hline 
		f & Profileid of the sender&Uint \\
		\hline 
		date&The date that this message is sent, this value can be empty, possible format should be $ xxxxxxxx $ e.g. $ 20200201 $&Uint\\	\hline
		msg& The message contents& String\\\hline 
	\end{tabular} 
	\caption{Buddy message command in prefix}
	\label{Buddy message command in prefix}
\end{table}

Next following subsections we introduce message contents,  the message content will use in both client buddy message and server buddy message. We only write the message contents after \tbs msg\tbs.
\subsubsection{Message}
This is a general message

\begin{mybox}
	\tbs msg\tbs<message content>\tbs final\tbs
\end{mybox}


\subsubsection{UTM}

\begin{mybox}
	\tbs msg\tbs<UTM message>\tbs final\tbs
\end{mybox}


\subsubsection{Request}
This is a add friend request.
\ServerResponse

\begin{mybox}
	\tbs msg\tbs|signed|<signature>\tbs final\tbs
\end{mybox}

\subsubsection{Auth}
Auth method do not have contents after $ \backslash date \backslash $.
\subsubsection{Revoke}
Revoke method is called when a client1 deleted a client2 in his friend list. When deletion is finished in client1, client1 will send revoke message to GPCM, GPCM will forward this message to client2, then client2 will delete player1 in his friend list.
Revoke method do not have contents after $ \backslash date \backslash $.
\subsubsection{Status}\label{Buddy Status}
This is an old method for game to get status information. buddy status \ref{Buddy Status} and buddy status info \ref{Buddy Status Info} can not be used at same time. Buddy status method is a part of Buddy Message module, old game send buddy status through a buddy message.
\ServerResponse

\begin{mybox}
	\tbs msg\tbs|s|<status code>|ss|<status string>|ls|<location string>\\
	|ip|<ip address>|p|<port>|qm|<quiet mode flag>\tbs final\tbs
\end{mybox}


\subsubsection{Invite}
Invite method is used to invite a player to a game which is currently playing by another player.

\ClientRequest

\begin{mybox}
	\tbs msg\tbs|p|<product id>|l|<location string>\tbs final\tbs
\end{mybox}



\subsubsection{PING}
Ping method maybe is used to check the ping to other player. 
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client1};  
		\node[block,right=150pt of a] (b) {GPCM};
		\node[block, below= of a] (c) {Cilent2};
		
		\draw[line] ([yshift=8]a.east)--node [fill = white] {1.Send PING request} ([yshift=8]b.west);
		
		\draw[line] ([xshift=-16]b.south)|-node [fill = white] {2.Forward PING request} ([yshift=8]c.east);
		
		\draw[line] ([yshift=-8]c.east)-|node [fill = white] {3. Send Pong Response} ([xshift=16]b.south);
		
		\draw[line] ([yshift=-8]b.west)--node [fill = white] {4.Forward PONG response} ([yshift=-8]a.east);
		\end{tikzpicture}
	}
	\caption{PING and PONG diagram}
	\label{PING and PONG diagram}
\end{figure}

\ClientRequest

\begin{mybox}
	\tbs msg\tbs\tbs final\tbs
\end{mybox}

\subsubsection{PONG}

\ServerResponse

\begin{mybox}
	\tbs msg\tbs 1\tbs final\tbs
\end{mybox}

\subsection{Buddy Status Info}\label{Buddy Status Info}
This is a new method used in new game. \ref{Buddy Status} is an old method used in old game. Currently we can not tell you which game use new method and which use old method.


\ServerResponse

\begin{mybox}[label=Buddy status info string]
	\tbs bsi\tbs\tbs state\tbs <buddy status>\tbs profile\tbs<profileid>\tbs bip\tbs<buddy ip>\\
	\tbs bport\tbs<buddy port>\tbs hostip\tbs <host ip>\tbs hprivip\tbs<host private ip>\\
	\tbs qport\tbs<query port>\tbs hport\tbs<host port>\tbs sessflags\tbs<session flags>\\
	\tbs rstatus\tbs<rich status>\tbs gameType\tbs<game type>\tbs gameVnt\tbs<game variant>\tbs gameMn\tbs<game map name>\tbs product\tbs<productid>\\
	\tbs qmodeflags\tbs<quiet mode flags>\tbs final\tbs
\end{mybox}

\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline 
		\textbf{Keys}& \textbf{Description}&\textbf{Type}  \\ 
		\hline 
		bsi & buddy status info command & \\ 		
		\hline 
		state & Buddy status state&Enum \\
		\hline 
		profileid&The profileID &Uint\\	\hline 
		bip& Buddy ip &String\\	\hline 
		bport&Buddy port&Uint\\\hline
		hostip& Host ip&String\\\hline
		hprivip&Host private ip&String\\\hline
		qport&Query port&Uint\\\hline
		hport&Host port&Uint\\\hline
		sessflags&Session flag&Uint\\\hline
		rstatus&Rich status ?&String\\\hline
		gameType&Game type&String\\\hline
		gameVnt&Game variant&String\\\hline
		gameMn&Game map name&String\\\hline
		product&Productid&uint\\\hline
		qmodeflags&Quiet mode flag&Enum\\\hline
	\end{tabular} 
	\caption{Buddy status info keys}
	\label{Buddy status info keys}
\end{table}

\subsection{Buddy List}
Buddy list is a list which contains your friends.
GPCM server will send buddy list when a client is logged in. Process is showing in Fig~\ref{Buddy List} and the response is showing in \ref{Buddy list string}.
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPCM};
		\draw[line] (b)--node [fill = white] {Send Buddy List} (a);
		\end{tikzpicture}
	}
	\caption{Buddy List}
	\label{Buddy List}
\end{figure}

\ServerResponse

\begin{mybox}
	\label{Buddy list string}
	\tbs bdy\tbs<number of profileid>\tbs list\tbs<profileid 1>,
	\\<profileid 2>,$ \cdots $,<profileid n>\tbs final\tbs
\end{mybox}


\subsection{Block List}
Block list is an list which contain the players you do not like.
GPCM server will send block list when a client is logged in. Process is showing in Fig~\ref{Block List} and the response is showing in \ref{Block list string}.
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPCM};
		\draw[line] (b)--node [fill = white] {Send Block List} (a);
		\end{tikzpicture}
	}
	\caption{Block List}
	\label{Block List}
\end{figure}

\ServerResponse

\begin{mybox}[label=Block list string]
\tbs blk\tbs <number of profile id>\tbs list\tbs<profileid 1>,<profileid 2>,$ \cdots $,\\<profileid n>\tbs final\tbs
\end{mybox}

\subsection{Add Buddy}
When a client want to add another client into his buddy list. He will send the following request to GPCM.

\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client1};  
		\node[block,right=200pt of a] (b) {GPCM};
		\node[block, below= of a] (c) {Cilent2};
		
		\draw[line] (a.east)--node [fill = white] {1.Send addbuddy request} (b.west);
		
		\draw[line] (b.south)|-node [fill = white] {2.Translate addbuddy to bm request} (c.east);

		\end{tikzpicture}
	}
	\caption{Add friend diagram}
	\label{Add friend diagram}
\end{figure}

\ClientRequest

\begin{mybox}
	\tbs addbuddy\tbs\tbs sesskey\tbs<session key>\tbs newprofileid\tbs<profile id>\\
	\tbs reason\tbs<add friend reason>\tbs final\tbs
\end{mybox}

\subsection{Delete Buddy}
When a client want to delete a friend in his buddy list. He will send the following request to GPCM.
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client1};  
		\node[block,right=200pt of a] (b) {GPCM};
		\node[block, below= of a] (c) {Cilent2};
		
		\draw[line] (a.east)--node [fill = white] {1.Send delbuddy request} (b.west);
		
		\draw[line] (b.south)|-node [fill = white] {2.Translate delbuddy to bm revoke} (c.east);
		
		\end{tikzpicture}
	}
	\caption{Delete friend diagram}
	\label{Delete friend diagram}
\end{figure}
\ClientRequest

\begin{mybox}
	\tbs delbuddy\tbs\tbs sesskey\tbs <session key>\tbs delprofileid\tbs <profile id>\tbs final\tbs
\end{mybox}


\section{GPI Info Module}
\subsection{Profile}
\subsubsection{Get Profile Information}
Find a user's profile information.
\ClientRequest

\begin{mybox}
	\tbs getprofile\tbs\tbs sesskey\tbs <session key>
	\tbs profileid\tbs <profile id>\\\tbs id\tbs <operation id>\tbs final\tbs
\end{mybox}
\ServerResponse

\begin{mybox}
	\tbs pi\tbs\tbs profileid\tbs <profile id>\tbs nick\tbs <nick name>\\\tbs uniquenick\tbs <uniquenick>\tbs email\tbs<email>\tbs firstname\tbs<first name>\\
	\tbs lastname\tbs <last name>\tbs icquin\tbs<icquin>\\
	\tbs homepage\tbs<home page URL>\tbs zipcode\tbs<zip code>\\
	\tbs countrycode\tbs<country code>\tbs lon\tbs <longitude>\tbs lat\tbs<latitude>\\
	\tbs loc\tbs<location>\tbs birthday\tbs<birthday>\tbs sex\tbs<gender>\\
	\tbs pmask\tbs<public mask>\tbs aim\tbs<aim name>\tbs pic\tbs <picture>\\
	\tbs occ\tbs<occupation id>\tbs ind\tbs<industry id>\tbs inc\tbs<income id>\\
	\tbs mar\tbs<married id>\tbs chc\tbs<child count number>\tbs i1\tbs<interest 1>\\
	\tbs  o1\tbs<ownership 1>\tbs conn\tbs<connection type id>\\
	\tbs sig\tbs<peer to peer signature>\tbs id\tbs <operation id>\tbs final\tbs
\end{mybox}

Keys in profile module:
\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|}
		\hline 
		\textbf{Key}&\textbf{Description} \\ 
		\hline 
		cpubrandid&            cpu barand id\\\hline
		cpuspeed& cpu speed\\\hline
		memory&memory\\\hline
		videocard1ram& GPU memory size\\\hline
		videocard2ram& GPU memory size\\\hline
		connectionid&connection id\\\hline
		connectionspeed&connection speed\\\hline
		hasnetwork& unknow\\\hline
		passwordenc& encrypted password\\\hline
	\end{tabular} 
	\caption{Other keys in profile}
	\label{Other keys in profile}
\end{table}

\subsubsection{Update Profile Information}
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPCM};
		\draw[line] (a)--node [fill = white] {Send update profile request} (b);
		\end{tikzpicture}
	}
	\caption{Update profile diagram}
	\label{Update profile diagram}
\end{figure}
\ClientRequest

\begin{mybox}[label = update profile request]
	\tbs updatepro\tbs\tbs sesskey\tbs<session key>\tbs $\star$\tbs partnerid\tbs<partner id>\\\tbs final\tbs
\end{mybox}
The $\star$ in \ref{update profile request} is the profile information key and value pairs such as\textbf{ \tbs nick\tbs<nick name>\tbs}, etc.
\subsubsection{Update User Information}
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPCM};
		\draw[line] (a)--node [fill = white] {Send update profile request} (b);
		\end{tikzpicture}
	}
	\caption{Update user diagram}
	\label{Update user diagram}
\end{figure}
\ClientRequest
The $\star$ in \ref{update user request} is the profile information key and value pairs such as \textbf{\tbs passwordenc\tbs<encrypted password>\tbs}, etc.
\begin{mybox}[label = update user request]
	\tbs updateui\tbs\tbs sesskey\tbs<session key>\tbs $\star$\tbs final\tbs
\end{mybox}



\subsection{GPI Profile Module}

\subsubsection{Create New Profile}
Create a new profile with nick name.
\ClientRequest

\begin{mybox}
	\tbs newprofile\tbs\tbs sesskey\tbs <session key>\tbs nick\tbs <nick name>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}
\subsubsection{Replace Existed Profile}
Replace nick name in a profile with a new nick name.
\ClientRequest

\begin{mybox}
\tbs newprofile\tbs\tbs sesskey\tbs <session key>\tbs nick\tbs <old nick name>\tbs replace\tbs 1\\\tbs oldnick\tbs<nick name>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}

\subsubsection{Delete Profile}
\ClientRequest

\begin{mybox}
	\tbs delprofile\tbs\tbs sesskey\tbs<session key>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}
\ServerResponse

\begin{mybox}
	\tbs dpr\tbs final\tbs
\end{mybox}



\subsection{GPI Unique Module}

\subsubsection{Register Unique Nick}
This method will register a new unique nick. There are two request \ref{register uniquenick1} and \ref{register uniquenick2}. The first one is only register unique nick, and the second one is register unique nick with cd key.
\ClientRequest
\begin{mybox}[label=register uniquenick1]
	\tbs registernick\tbs\tbs sesskey\tbs<session key>\tbs uniquenick\tbs<unique nick>\\\tbs partnerid\tbs<partner id>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}
\begin{mybox}[label=register uniquenick2]
	\tbs registernick\tbs\tbs sesskey\tbs<session key>\tbs uniquenick\tbs<unique nick>\\\tbs cdkey\tbs<cd key>\tbs partnerid\tbs<partner id>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}

\ServerResponse
\begin{mybox}
	\tbs rn\tbs final\tbs
\end{mybox}


\subsubsection{Register CD Key}
\ClientRequest
\begin{mybox}
	\tbs registercdkey\tbs\tbs sesskey\tbs<session key>\tbs partnerid\tbs <partner id>\tbs id\tbs <operation id>\tbs final\tbs
\end{mybox}
\ServerResponse
\begin{mybox}
	\tbs rc\tbs final\tbs
\end{mybox}
\subsection{GPI Peer Module}
\subsection{GPI Transfer Module}



\chapter{GameSpy Presence Search Player}
GPSP server provides search function for client.\\
Table \ref{IP and Ports for GameSpy Presence Servers} are the GPSP IP and Ports that client/game connect to.

\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPSP};
		\draw[line] ([yshift=8]a.east)--node [fill = white] {1.Send client search request} ([yshift=8]b.west);
		\draw[line] ([yshift=-8]b.west)--node [fill = white] {2.Send search result} ([yshift=-8]a.east);
		\end{tikzpicture}
	}
	\caption{GPSP diagram}
	\label{GPSP diagram}
\end{figure}

\section{Search Profile}
\ClientRequest 

\begin{mybox}
	\tbs search\tbs\tbs sesskey\tbs<session key>\tbs profileid\tbs <profile id>\tbs $\star$\\\tbs namespaceid\tbs<namespace id>\tbs partnerid\tbs<partner id>\\\tbs gamename\tbs<game name>\tbs final\tbs
\end{mybox}

Symbol $\star$ contains client detail, we list client detail as follows.
\begin{mybox}
	\tbs nick\tbs<nick name>\tbs uniquenick\tbs <unique nick>\tbs email\tbs<email>\\\tbs firstname\tbs<first name>\tbs lastname\tbs<last name>\tbs icquin\tbs <icq uin>\\\tbs skip\tbs<skip>
\end{mybox}


\ServerResponse

\begin{mybox}[label = search user response]
	\tbs bsr\tbs\textbf{<profile 1>}\tbs bsr\tbs\textbf{<profile 2>}\tbs bsr\tbs $\cdots$\tbs \textbf{<profile n>}\\
	\tbs bsrdone\tbs\tbs more\tbs<number of rest profiles>\tbs final\tbs
\end{mybox}
The value in \textbf{<profile i>} is showing below \ref{content after bsr}.
\begin{mybox}[label = content after bsr]
<profileid>\tbs nick\tbs<nick>\tbs uniquenick\tbs<unique nick>\\\tbs namepaceid\tbs <namespace id>\tbs firstname\tbs<first name>\\\tbs lastname\tbs<last name>\tbs email\tbs<email>
\end{mybox}
\subsection{Seach Profile With Unique Nick}
\ClientRequest
\begin{mybox}
	\tbs searchunique\tbs\tbs sesskey\tbs<session key>\tbs profileid\tbs<profile id>\\\tbs uniquenick\tbs<unique nick>\tbs namespaces\tbs<namespace id 1,\\ namespace id 2, ..., namespace id n>\tbs final\tbs
\end{mybox}
\ServerResponse
The response from server is the same as \ref{search user response}.
\subsection{Search User Is Valid}
\ClientRequest

\begin{mybox}
	\tbs valid\tbs\tbs email\tbs<email>\tbs partnerid\tbs<partner id>\tbs final\tbs
\end{mybox}

\ServerResponse

Number 0 represents false, 1 represents true.
\begin{mybox}
	\tbs vr\tbs <valid code: 0 or 1>\tbs final \tbs
\end{mybox}

\subsection{Search Nick}
This method is used to search profile with nick name and email.
\ClientRequest

\begin{mybox}
	\tbs nicks\tbs\tbs email\tbs <email>\tbs passenc\tbs<encrypted password>\\\tbs namespaceid\tbs <namespace id>\tbs partnerid\tbs<partner id>\\\tbs gamename\tbs<game name>\tbs final\tbs
\end{mybox}

\ServerResponse

\begin{mybox}
	\tbs nr\tbs\tbs nick\tbs<data 1>\tbs<data 2>\tbs $\cdots$\tbs <data n> \tbs ndone\tbs final\tbs
\end{mybox}
The content in \textbf{<data i>} shows below.
\begin{mybox}
	 <nick name>\tbs uniquenick \tbs<unique nick>
\end{mybox}

\subsection{Search Player}

\ClientRequest

\begin{mybox}
	\tbs pmatch\tbs\tbs sesskey\tbs<session key>\tbs profileid\tbs<profile id>\\\tbs productid\tbs <product id>\tbs gamename\tbs <game name>\tbs final\tbs
\end{mybox}

\ServerResponse
\begin{mybox}
	\tbs psr\tbs <data 1>\tbs psr\tbs<data 2>\tbs $\cdots$\tbs psr\tbs <data n>\tbs psrdone\tbs final\tbs
\end{mybox}
The content in \textbf{<data i>} shows below.
\begin{mybox}
	<profile id>\tbs status\tbs<status string>\tbs nick\tbs<nick name>\\\tbs statuscode\tbs<status code>
\end{mybox}


\subsection{Search Check}
This method is used to check whether user exist.
\ClientRequest

\begin{mybox}
	\tbs check\tbs\tbs nick\tbs <nick name>\tbs email\tbs<email>\tbs partnerid\tbs <partner id>\\\tbs passenc\tbs<encrypted password>\tbs gamename\tbs<game name>\tbs final\tbs
\end{mybox}

\ServerResponse
The error code in \ref{search check response} shows in .
\begin{mybox}[label = search check response]
	\tbs cur\tbs<check error code>\tbs pid\tbs <profile id>\tbs final\tbs
\end{mybox}

\subsection{User Creation}
This commmand \ref{Create user command} is used to create a user in GameSpy.
\ClientRequest

\begin{mybox}[label = Create user command]
\tbs newuser\tbs email \tbs <email>\tbs nick\tbs < nick name> \\
\tbs passwordenc\tbs <password enc>\tbs productid\tbs <product id>\\\tbs uniquenick\tbs <unique nick>
\tbs cdkeyenc\tbs <cdkeyenc>\\\tbs partnerid\tbs <partnerid>\tbs gamename\tbs <gamename>\tbs final\tbs
\end{mybox}

\ServerResponse
The newuser error code shows in .
\begin{mybox}
	\tbs nur\tbs<newuser error code>\tbs pid\tbs <profile id>\tbs final\tbs
\end{mybox}

\subsection{Search Others Buddy}
\ClientRequest

\begin{mybox}
	\tbs others\tbs\tbs sesskey\tbs<session key>\tbs profileid\tbs<profile id>\\\tbs namespaceid\tbs <namespace id>\tbs gamename\tbs<game name>\tbs final\tbs
\end{mybox}
\ServerResponse
GPSP should try to find the information, if some account do not have unique nick then do not add \tbs uniquenick\tbs<unique nick>\tbs to response string.
\begin{mybox}
\tbs others\tbs\tbs o\tbs<data 1>\tbs o\tbs <data 2>\tbs $\cdots$\tbs <data n>\tbs odone\tbs final\tbs
\end{mybox}
The content in \textbf{<data i>} is listed as follows.
\begin{mybox}
	<profile id>\tbs nick\tbs <nick name>\tbs uniquenick\tbs<unique nick>\\\tbs first\tbs<first name>\tbs last\tbs <last name>\tbs email\tbs<email>
\end{mybox}


\subsection{Search Others Buddy List}
Client send request to GPSP asking for the buddy's profiles with buddy profile id.
\ClientRequest

\begin{mybox}
	\tbs otherslist\tbs\tbs sesskey\tbs <session key>\tbs profileid\tbs<profile id>\\
	\tbs numopids\tbs<number of recieved buddy profiles>\\
	\tbs opids\tbs <profile id 1>|<profile id 2>|$\cdots$|<profile id 3>\\
	\tbs namespaceid\tbs <namespace id>\tbs gamename\tbs <game name>\tbs final\tbs
\end{mybox}
\ServerResponse

\begin{mybox}
	\tbs otherslist\tbs\tbs o\tbs<data 1>\tbs o\tbs<data 2>\tbs $\cdots$\tbs <data n>\tbs odone\tbs final\tbs
\end{mybox}
The content in \textbf{<data i>} is listed as follows.
\begin{mybox}
	<profile id>\tbs uniquenick\tbs <unique nick>
\end{mybox}



\subsection{Search Suggest Unique}

Client search suggest nick name on GPSP.

\ClientRequest
\begin{mybox}
	\tbs uniquesearch\tbs\tbs preferrednick\tbs<unique nick name>\\
	\tbs namespaceid\tbs<namespace id>\tbs gamename\tbs<game name>\tbs final\tbs
\end{mybox}
\ServerResponse
\begin{mybox}
	\tbs us\tbs<number of suggest nick>\tbs nick\tbs <nick name1>\\
	\tbs nick\tbs<nick name2>\tbs $\cdots$\tbs nick\tbs <nick name n>\tbs usdone\tbs final\tbs
\end{mybox}








\part{Transport}






\part{NAT Negotation}

\chapter{Introduction}
The GameSpy NAT Negotiation SDK interacts with GameSpy's NAT Negotiation server to allow hosting of multiplayer games by users behind NAT and firewall devices. Typically, a user behind a NAT or firewall device cannot host multiplayer games because the device will block incoming connections from outside users. GameSpy's NAT Negotiation technology allows two users, one or both of whom are behind a NAT device, to open a clear UDP channel directly between the users.
GameSpy's NAT Negotiation technology uses a method known as "Port Guessing" to attempt to discern future port mapping information for two users based on their connections to the NAT Negotiation server. Once this mapping information is determined, the server exchanges the information with the users, and they connect to each other directly (note: the term "connect" in this document is understood to mean the establishment a clear, two-way channel between the users, since UDP is in reality a connection-less protocol).

Note that the NAT Negotiation SDK does not make any distinction between the "client" who is connecting to a "server" (or "host"), however this document will use those terms for clarity, and because the other SDKs involved do make that distinction.

The NAT Negotiation SDK itself is very simple - two users who want to be connected to each other have a shared "cookie" value that the NAT Negotiation server uses to match the users up. 

The NAT Negotiation SDK has no limit to the number of users that can be connected together, but each channel between two users must be independently established.



\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node [block]  (a) at (5,5){NATNEG};
		\node [block] (b) at (0,0){Client 1};
		\node [block](c) at (10,0){Client 2};
		
		\draw[line] ([xshift = -15]a.south)--node [midway, below, sloped] {\circled{\small{2}} Client2 connect request} ([xshift=10]b.north);
		
		\draw[line] ([xshift=-10]b.north)--node [midway, above, sloped] {\circled{\small{1}} Heat beat} ([xshift = -35]a.south);
		
		\draw[line] ([xshift =15]a.south)--node[midway, below, sloped] {\circled{\small{2}} Client 1 connect request} ([xshift=-10]c.north);
		\draw[line] ([xshift=10]c.north) -- node[midway, above, sloped] {\circled{\small{1}} Heart beat} ([xshift=35]a.south);
		
		
		\draw[line] ([yshift=8]b.east)--node[fill=white]{\circled{\small{3}} Connect to each other}([yshift=8]c.west);
		
		\draw[line] ([yshift=-8]c.west)--node[fill=white]{\circled{\small{3}} Connect to each other}([yshift=-8]b.east);
		
		\end{tikzpicture}
	}
\caption{NatNeg working diagram}
\label{NatNeg working diagram}
\end{figure}


\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline 
		\textbf{Name}&\textbf{IP}&\textbf{Port}\\ 
		\hline 
		NATNEG&natneg1.gamespy.com&27901 (udp) \\ 
		\hline
				NATNEG&natneg3.gamespy.com&27901 (udp) \\ 
		\hline 
				NATNEG&natneg2.gamespy.com&27901 (udp) \\ 
		\hline 
	\end{tabular} 
	\caption{IP and Ports for NatNeg Servers}
	\label{IP and Ports for NatNeg Servers}
	
\end{table}


Nat Negotiation mechanism:
Because the ip address and other environment are changing from time to time, so when a client1 wants to connect
to client2, he dose not know any informations about client2, so he cannot connect to client2. using natneg it can ask client2 information on gamespy nat server and connect to client2.

Nat Negotiation SDK do the following things:
\begin{itemize}
	\item Clients connect to GameSpy NatNeg server
	\item Clients send the heart beat data that contain all information about himself to GameSpy NatNeg server
	\item GameSpy Nat server store clients information.
	\item when a client1 is try to connect to other client2:
	\begin{itemize}
		\item client1 send request to GameSpy NatNeg server
	\item GameSpy NatNeg server send the information about client2 to client1
		\item  client1 get the client2 information and connect.
	\end{itemize}
	

\end{itemize}




\section{NetNag Packet}

\begin{mybox}
	typedef struct \_NatNegPacket \\
	\{\\
	unsigned char magic[NATNEG\_MAGIC\_LEN];\\
	unsigned char version;\\
	unsigned char packettype;\\
	int cookie;	\\
	
	union\\
	\{\\
	InitPacket Init;\\
	ConnectPacket Connect;\\
	ReportPacket Report;\\
	\} Packet;\\
	
	\} NatNegPacket;
\end{mybox}

\subsection{Magic Data}
Every heart beat packet start with magic data.
\begin{mybox}
	Magic Data: 0xFD 0xFC 0x1E 0x66 0x6A 0xB2
\end{mybox}

\subsection{NatNeg Packet Type}
Client's heart beat contains NatNeg packet type which we list as follows.

\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Packet type} &\textbf{Description}&\textbf{Value}\\\hline
		Init && 0\\\hline
		ErtTest&Echo packet to original sender test&2\\\hline
		Connect&&5\\\hline
		Connect Ack&&6\\\hline
		Connect ping&& 7\\\hline
		BackupTest&&8\\\hline
		Address check&& 10\\\hline
		Natify request&&12\\\hline
		Report && 13\\\hline
	\end{tabular}
	\caption{NatNeg client request packet type}
	\label{NatNeg client request packet type}
\end{table}


\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Packet type} &\textbf{Description}&\textbf{Value}\\\hline
		InitAck&&1\\\hline
		ErtAck&Echo packet remote to sender&3\\\hline
		Backup Ack&&9\\\hline
		Address reply&&11\\\hline
		Report Ack&&15\\\hline
	\end{tabular}
	\caption{NatNeg server response packet type}
	\label{NatNeg server response packet type}
\end{table}


%Magic: 0xFD 0xFC 0x1E 0x66 0x6A 0xB2
%Version: 0x03
%
%Command 1: Natify Request (0x12)
%Cookie: htonl(777)
%
%Sets Packet Init. portType to 1 if Natneg server is natneg1, 2 if it's natneg2, 3 if it's natneg3
%
%Command 2: Address check (discover mapping)
%
%Sets portType to as the same as Command 1
%Cookie is htonl(0 for natneg1 (map1A), 1 for natneg2, 2 for natneg3, 3 for natneg1 second map (Map1B))


\subsection{Initial Packet}
\begin{mybox}
	typedef struct \_InitPacket\\
	\{\\
	unsigned char porttype;\\
	unsigned char clientindex;\\
	unsigned char usegameport;\\
	unsigned int localip;\\
	unsigned short localport;\\
	\} InitPacket;\\
\end{mybox}

\subsection{Report Packet}

\begin{mybox}
	\#define REPORTPACKET\_SIZE BASEPACKET\_SIZE + 61\\
	typedef struct \_ReportPacket\\
	\{\\
	unsigned char porttype;\\
	unsigned char clientindex;\\
	unsigned char negResult;\\
	NatType natType;\\
	NatMappingScheme natMappingScheme;\\
	char gamename[50];\\
	\} ReportPacket;\\
\end{mybox}



\subsection{Connect Packet}

\begin{mybox}
	\#define CONNECTPACKET\_SIZE BASEPACKET\_SIZE + 8\\
	typedef struct \_ConnectPacket\\
	\{\\
	unsigned int remoteIP;\\
	unsigned short remotePort;\\
	unsigned char gotyourdata;\\
	unsigned char finished;\\
	\} ConnectPacket;\\
\end{mybox}













\part{Peer to Peer communication}
\part{Patching \& Tracking}
\part{Query \& Reporting}
Custom keys are used to define custom data to report, for example if the user is playing with a
Windows or Machintosh PC.

There could be two types of custom keys:
Player keys (they end with \_):
Custom player information
Team keys (they end with \_t):
Custom team (or brigade) information
Server keys (they don't end with anything):
Custom server information

Custom keys starts from 50 to 253


IP: gamename.master.gamespy.com
Port 27900
Protocol: UDP

There is more than one Query report ports, if 27900 is not found the system will 
try to scan the ports up to 28000

A dedicated server sends some information data to GameSpy Master Server to let GameSpy know
that a new server was started, so users can find the server in the server browser
like GameSpy 3D or GameSpy Arcade.

A server needs to be registred to GameSpy master Server, it's done with a challenge
Sending the heartbeat challenge packet and processing the response.
If an error happens, the AddError packet is sended.

A. Heartbeat (Only done if the server is public)
The heartbeat checks if the dedicated server is active or not.
When a dedicated servers sends a data, the time when the data is sended is saved in the Master server.
If the Master server does not receive a new data in 10 seconds, Master server removes the dedicated server
to the list and assumes the server is offline.

The dedicated server have to send the heartbeat packet each 10 seconds in order to maintain his connection
alive.

The Instance key is a random 4 bytes array characters generated by the client when it tries
to connect to the server

The heartbeat communicates everything new it happends to the server, like someone connected or similar.
\\
Keep alive packet:
A 5 bytes buffer composed by
0x08 (The packet id)
Instance key
\\
3 types of heartbeat packets
Type 3: Challenge heartbeat
Type 2: A server is shutting down
Type 1: User requested a change in the game data
Type 0: Normal heartbeat
\\
General heartbeat packet:

0x03 (The Packet ID)
Instance key
\\
A key represents the information of a data, much like a Dictionary (Similar to GPSP, but it uses $\backslash$0 rather than $\backslash\backslash$) 
\\
List of known keys:
localipX (Where X is the number of local IP starting from 0): Local IP of the server
localport: Query port binded by the server, where the Master Server can connect to
natneg: If you can nat negotiate with the server (If you do, the keep alive packet will also be sended)
statechanged: Integer (Type of heartbeat, see above)
gamename: Name of the game
\\
If the server want to track the local clients public ip, also this two extra parameters will be sended:
publicip: Public IP of the server
publicport: Public port
\\
The custom keys are now added with their respective value
Server, Player and Team
\\

NOTE: In the heartbeat, we are always querying the current known keys, so
rather than being "customkey\_one\tbs0customkey\_one\_data\tbs0" it's just "customkey\_one\tbs0\tbs0"
\\
(Each key is delimited by \tbs0)
\\
B. Check queries (Process any new query)
\\
We receive some data from the server.
\\
CD-Key query:
They start with 0x3B, nothing else is known
See CD-KEY Reverse for more information
\\
Query Report 1 queries (compatibility):
They start with $\backslash$
\\
Nat Negotiation query:
If the length is bigger than 6 and we find the NatNeg magic data
See NatNeg Reverse for more information
\\
Query Report 2:
If the first two bytes are 0xFE and 0xFD
\\
Query Report 2 Queries:
Structure:
Byte \[0\] = 0xFE
Byte \[1\] = 0xFD
Byte \[2\] = Packet type
Byte \[3-10\] = Request key (An array long 7 bytes)
\\
After all the queries are processed, the dedicated server sends back some data.
Which can be the challenges or something different.


Packet types:

Query (0x00)
This packet verify the IP of the client by checking if the random data
it was sended before (With 0x09) is the same. If it isn't the server won't
verify the client.

The dedicated server will send a notification to the Master Server about who
authenticated and who didn't

A character from the start of the data is called EXFlags and they are used to see if the QR2
server supports different things (an example is: Split if the server supports splitting the queries)

Maximum of 7 queries can be splitted

How a query is created:
A key called splitnum is created which contains the current number of key splitted
The key type (server, team or player)
The key data

Challenge (0x01)
This packet is used for verify the server with the master server.

Calculate the challenge:
First the backend option, each server can have some custom backend option, like disabling the Query Report challenge
The data sended is the following:

\[2 Bytes that are the backend option with a \backslash 0\] \\
\[Public IP (Length of 8, readed with htonl) and Port (length of 4)\]\\
\[ Max of 64 bytes containg a random data that will be the challenge, this is much like GPCM \]\\

Algorithm of calculating the challenge (Client side):

See qr2.c at line 785 (compue\_challenge\_response) for more information
A. Encrypt the challenge with the secret key
B. Encode the encrypted challenge

Echo (0x02)
Simply reply the same data as the server sended

The first byte is 0x05
Then the data the server sended (max 32 bytes are allowed)

Heartbeat (0x03)
Check "General heartbeat packet"

Add Error (0x04)
The master server sends an error to the dedicated server
For example about Server registration (Failed challenge)

Echo response (0x05)
This is a response of the Echo packet that Server sended to Client
Server to Client ID is 0x02, Client to Server ID is 0x05

Client Message (0x06)
Sends the following data (After the packet structure)

The first byte is 0x07 (Message ACK)
The other 4 bytes is the length of the message key

There can be sent a Nat negotiation packet now (With the natneg magic)
Or it can be a normam data

Max 10 messages to track

0x07???

Keep alive (0x08)
Ignored packet

Prequery IP Verify (0x09) [Server to Client only]
Try to verify the IP of a client that connects to the server.
This is only done if the user enable the IP challenge.
Each new client has to verify themself with a challenge.

A new key is added to the data to send:



%CD-Key/NatNeg authentication to QR2:
%Client ------> Query Report 2 ------> CD-Key/NatNeg Server -----> Query Report 2 (Filtered with CD-KEY or NatNeg Request) -----> Client

\part{Server Browser}
%UDP and ICMP sockets
%
%Connect to: ms<index>.gamespy.com:28910 (TCP)
%Where index is the index of the server, up to 20 multiple servers are supported.
%
%NOTE: Strings are null terminated
%
%Connect request:
%First three bytes: Message ID (0x00), length of the data (done with htons)
%Data:
%0x01 (Protocol version)
%0x03 (Encoding version)
%int32 (Unknown, should be 0, called queryFromVersion in the SDK)
%string[36] (Server returned for this game name)
%string[36] (The current game name)
%string[8] (Challenge)
%Server filter (char* with 0x0 at the end)
%Field list (char* with 0x0 at the end)
%int32 (Options, done with htonl)
%If we are using an alternative source ip:
%int32 (server IP with htonl)
%If we limit the results we can get
%int32 (max servers to see)
%
%
%Response is a Query Report 2 query:
%First byte is 0x00 for a normal response
%First byte is 0x09 for a challenge response
%
%From byte 2 to 5 there are some skipped bytes (Request key)
%
%If the client is expecting a Query Challenge, it sends a normal IP verify query (See QR2 research)
%Otherwise it sends a normal Query to QR2 with Split packets support
%It could request all keys or a basic query with not player or team queries and just some server queries
%
%
%When A client request a server:
%
%Request  :: Client (GameSpy 3D) -------> Server Browser (TCP 28910) --------> Query Report 2 Server (UDP 27901)
%Response :: Query Report 2 ------> Server Browser (Parse the QR2 data, filter it) -----> Client
%
%The server browser is like a high-level Query Report 2 server, it helps creating a server browser without having to
%do everything manually on the Query Report. An interpreter server for QR2.
%
%Get Server rules (Client request) from Server Browser server:
%First two bytes, htons(message length)
%Third byte: 0x01 (Server Info request)
%4 bytes: IP of server
%2 bytes: Port of server
%
%Send Message to the Server:
%First two bytes, htons(message length)
%Third byte: 0x02 (Send Message request)
%4 bytes: IP
%2 bytes: Port
%
%After this is done, the client sends the message (null terminated) to the Master Server (Server Browser server)
%
%Send NatNeg cookie to server:
%This just do a normal Send message to server function (see above)
%But the data is sended is a natneg request:
%First 6 bytes: NatNeg 6 magic (0xFD, 0xFC, 0x1E, 0x66, 0x6A, 0xB2)
%4 bytes for the cookie (htonl(cookie))
%
%
%Send MapLoop request:
%First two bytes, htons(message length)
%Third byte: 0x04 (MapLoop request)
%4 bytes: Public IP of server
%2 bytes: Public Port of server
%
%Send PlayerSearch request:
%First two bytes, htons(message length)
%Third byte: 0x05 (PlayerSearch request)
%4 bytes: Search option (htonl(searchOptions))
%4 bytes: Max result
%Null terminated string containing the name
%
%
%Server Browser responses:
%Main data (Or Server data):
%All data is crypted with GOA (Or Query Report 1 Server) algorithm for the cryptation key that is:
%Secret QR2 key + Challenge + Server Challenge		
%sb_serverlist.c line 797
%
%Data sended from server, header of crypted data:	
%[Length of Data] [Game Flags] [Data] [Length of Key] [Key Data]
%Byte 0: Length of the data (The length is XORed with 0xEC)
%Byte (Length of data - 1): Key length (Xored with 0xEA)
%The key data is used to decrypt the data
%Byte 1-2: Game flags (Setted by the dedicated server) and used htons
%The data is decrypted with GOA (QR1 Cryptation)
%
%Fixed Header (First 6 bytes of decrypted data):
%[Public IP] [Default port]
%PublicIP of the client requesting: 4 bytes
%Default port of the client requesting: 2 bytes (if it's 0xFFFF then there was an error)
%
%Error Data: It's contained after the fixed header to the end, null terminated
%Data:
%[Key List] [Unique Value List] [Server list]
%
%Key List:
%[Length of keys] [KeyInfo] [KeyInfo 2] [...]
%Length of keys: One byte (Max 255 Key infos)
%Key Info:
%[Key length] [Key Name] [Key Type]
%Key length: One byte
%Key name: Null terminated at the end
%
%Types of keys:
%0x01: KeyInfo byte (value length is 1)
%0x02: KeyInfo short (value length is 2)
%0x00: KeyInfo string
%The first byte is the index, if it's 0xFF then it's a null terminated string
%otherwise we already have the length when we parsed the keys
%
%
%Unique Value List:
%[Length of unique values] [Unique value] [Unique Value 2] [....]
%Length of uvalues: One byte (Max 255 unique values)
%Unique value: Null terminated string
%
%
%Server list:
%[Server Info] [Server Info 2] [...] [Last Server Info]
%
%Server Info:
%[Flags] [IP] [Port (Optional)] [Server Data (Optional)]
%Flags: One byte, if bit 5 of flags is setted (flags | 16), then the server does not use a default game port
%So, after the IP, The port data will be setted
%IP: 4 bytes containing the IP
%Port: 2 bytes
%
%Server Data:
%[Private IP] [Private Port] [ICMP IP] [KeyInfo...]
%If bit 2 of flags is setted, then we have the Private IP of the server
%The private IP length is 4
%
%If bit 6 is setted, the server uses a custom private port (not the default one)
%Private port length is 2
%
%If bit 4 is setted, the server have an ICMP server used
%ICMP IP length is 4
%
%If bit 7 is seteted, the server have some custom keys
%The length was setted when we where parsing the Key List data
%
%
%If bit 8 is setted, then we have the game full rules
%All the strings inside the full game rules are null terminated
%[Rule 1] [Rule 2] [...]
%
%
%Second data sended: AdHoc data (After the server/main data)
%This data is not crypted
%
%The first two byes is the message length (then htohs)
%The message can be at maximum 4096.
%
%The third byte is the message type
%Type 1: Push keys
%Add some keys to the server browser client
%The first character is the number of keys (max 255 keys)
%
%The keys follows the structure of KeyInfo
%
%Type 2: Server message
%Works the same as Server Info
%
%Type 3: Keepalive message
%All data the server sends it's replied back
%
%Type 4: Delete server
%[Server IP] [Server Port]
%Server IP: 4 bytes
%Server Port: 2 bytes (NOT OPTIONAL)
%
%Type 5: Maploop (Used when a new map needs to be selected)
%[Server IP] [Server Port] [Time] [Map Count] [Map Data] [Map Data 2...] [...]
%Server IP: 4 bytes
%Server Port: 2 bytes (NOT OPTIONAL)
%Time: 4 bytes (time_t)ntohl(time) rapresentation
%Map Count: One byte telling the number of maps avaiable
%Map Data: Null terminated string
%
%Type 6: Player Search
%[Is Final] [Result Count] [PlayerSearch Data] [PlayerSearch Data 2] [...]
%Is Final: 1 byte, when setted to 1, means the research is finished
%When setted to 0, the client have to expect another Type 6 adhoc packet
%Result Count: 1 byte telling the numbers of result that the playersearch produced
%
%PlayerSearch Data:
%[Nickname] [IP] [Port] [LastSeen] [Game name]
%Nickname: Null terminated string
%IP: 4 bytes
%Port: 2 bytes (not optional)
%Last Seen: 4 bytes, (time_t)ntohl(lastSeen)
%Game name: A null terminated string
%
%
%Get LAN server list:
%Client binds a socket that will be used for communicating with QR2 (Also multihomed support)
%Client sends a QR2 query request with ID 0x02 and 4 extra bytes (Called echo request) to Server Browser
%
%The QR2 socket is a broadcast socket
%
%When you create a  dedicated server in your lan, by using Query Report 2, GameSpy SB SDK discovers all
%dedicated servers opened in your network, if the dedicated servers reply the QR2 Echo Packet
%
%---------------------------------------------------- Master Server: ICMP -----------------------------
%
%Discovered with the SDK, we know that ICMP support can be disabled.
%It is confirmed to be used in platforms like PlayStation2.
%
%What server to connect?
%- If the Server (in the serverbrowser ServerData) define a custom ICMP IP, then connect to that
%- Otherwise, connect to the Public IP of the server
%
%Everything looks the same as ServerBrowsing reverse, the different seems to be that
%we can parse data not only from the Query socket (UDP) but from the ICMP socket
%
%Platforms that doesn't use ICMP:
%- Linux or any other Unix based distribution (like FreeBSD)
%- MacOSX
%- iPhone
%- Nintendo DS
%- Nintendo Wii
%
%The data follows a usual ICMP protocol: https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol
%Look at sb/sb_internal.h for more information about SBICMPHeader.
\part{SAKE Persistent Storage}
\part{ATLAS Competition}
\part{Voice Chat}
\part{Web Authentication}

\part{GameSpy Status \& Tracking}
\chapter{General Introduction}
\section{Note}
Game uses GSTATS to store its data only using email and passwords login method in GPCM. So we do not need to consider namespaceid, we only need to find profileid.


\section{Working Process}
\begin{enumerate}
	\item On startup, the host connects to tracking server, is authenticated, and is assigned a unique connection ID. If disk logging is enabled (see below) and there are logged games, they are sent to the tracking server. 
	\item When the actual game starts, the host sends a new game notification to the tracking server and creates internal structures for managing the game information. 
	\item During the game the host collects information into buckets (or developer's own data structures) and sends out snapshots at regular intervals (in case the host is reset before the game finishes) 
	\item (If player authentication is used) As players connect, the host sends out a challenge to the client, which formats a response based on its password or CD Key. This response is sent back to the host and stored as part of the snapshot. 
	\item When the game is complete, a final snapshot is sent to the tracking server. 
	\item A new game can be started immediately over the same connection (multiple simultaneous games over the same tracking server connection are supported as well). 
	\item The tracking server post-processes the data to extract some standard information and verify the authentication of the players. Disk logged or unusual games are marked for inspection. 
\end{enumerate}
\section{Message Encryption}
The GameSpy Stats \& Tracking (GSTATS) SDK provides a simple, secure way to report the results and statistics of games to a central server. These results can then be used to help facilitate online rankings, ladders, and tournaments. Tracking is done in a very abstract manner than can be applied to any type of multiplayer game.\\
The communication between client and GSTATS server is encrypted under an simple XOR method. After encrypted the message look like \ref{gstats encrypted message}.

\begin{mybox}[label = gstats encrypted message]
	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\tbs final\tbs
\end{mybox}


\section{Client Command}

\begin{table}[H]
	\centering
	\begin{tabular}{B}
		\hline
		\textbf{Command}&\textbf{Description}\\\hline
		auth~[\ref{gstats authentication}]& Authentication request\\\hline
		updgame&Sends a snapshot of information about the current game.\\\hline
		authp& Authenticates player\\\hline
		getpd& Gets persist data values modified\\\hline
		getpid& Ge sprofile id\\\hline
		newgame& Creates a new game for logging and registers it with the stats server.\\\hline
		
		
	\end{tabular}
\caption{GSTATS client request command}
\label{GSTATS client request command}
\end{table}
\section{Server IP and Port}

\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline 
		\textbf{Name}&\textbf{IP}&\textbf{Port}\\ 
		\hline 
		GSTATS&gamestats.gamespy.com&29920 (tcp) \\ 
		\hline 
	\end{tabular} 
	\caption{IP and Ports for GameSpy status and tracking}
	\label{IP and Ports for GameSpy status and tracking}
\end{table}


\chapter{Protocol Detail}
\section{Authentication}\label{gstats authentication}


\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GSTATS};
		\draw[line] ([yshift=15]b.west)--node [fill = white] {1.Send server challenge} ([yshift=15]a.east);
		\draw[line] (a.east)--node [fill = white] {2.Send client request} (b.west);
		\draw[line] ([yshift=-15]b.west)--node [fill = white] {3.Accept or reject} ([yshift=-15]a.east);
		\end{tikzpicture}
	}
	\caption{GSTATS authentication diagram}
	\label{GSTATS authentication diagram}
\end{figure}

\ServerChallenge

\begin{mybox}
	\tbs challenge\tbs<challenge string>\tbs final\tbs
\end{mybox}


\ClientRequest

\begin{mybox}[label = gstats auth request]
	\tbs auth\tbs\tbs gamename\tbs<game name>\tbs response\tbs<response string>\\
	\tbs port\tbs<game port>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}
The response string in\ref {gstats auth request} is computed using the secrete key~\ref{GameSpy Secret Key} of the client.\\

\ServerResponse

\begin{mybox}
	\tbs sesskey\tbs<session key>\tbs final\tbs
\end{mybox}

Session key should be Uint number.

when game wants to use the connect to GSTATS server, server will send an message to game which contains the challenge, the total length of message must bigger than 38bytes, and the challenge must bigger than 20bytes.
when game received the challenge it will compute a response, the response is formed as follows. 
response = CRC32(<server challenge>,<length of server challenge>)||<game secret key>
then game will compute the MD5 hash as MD5value = MD5(<response>,<length of response>)
then encoded with Enctype3
then construct the challenge-response message as $ \backslash auth \backslash \backslash gamename \backslash <gamename>\backslash response \backslash <MD5value> \backslash port \backslash <port> \backslash id \backslash <id> $

session key length (unknown)
connction id = transfer ascii of sessionkey to integer

the initialization phase is finished.
server challenge message length (bigger than 38-byte)
server challenge length (bigger than 20-byte)
$ \backslash final \backslash $ is not encrypted using XOR Enctype1 at the end of the challenge that sends by the server.

\section{Authenticate Player}

\subsection{Authenticate Player With Partner Information}
\ClientRequest
\begin{mybox}
	\tbs authp\tbs\tbs authtoken\tbs<authtoken string>\\\tbs resp\tbs response\tbs<response string>\tbs lid\tbs <local id>\tbs final\tbs
\end{mybox}
\ServerResponse

Server response is the same as \ref{gstats player auth server response}.
\subsection{Authenticate Player With Presence Connection Manager}
\ClientRequest
\begin{mybox}
	\tbs authp\tbs\tbs pid\tbs<profile id>\tbs resp\tbs<response string>\tbs lid\tbs <local id>\tbs final\tbs
\end{mybox}
\ServerResponse

Server response is the same as \ref{gstats player auth server response}.
\subsection{Authenticate Player With CD Key Hash}
\ClientRequest
\begin{mybox}
	\tbs authp\tbs\tbs nick\tbs<nick name>\tbs keyhash\tbs<cd key hash>\tbs resp\tbs <response string>\tbs lid\tbs<local id>\tbs final\tbs
\end{mybox}
\ServerResponse

Server response is the same as \ref{gstats player auth server response}.

The challenge response string here is calculated from password and the connection id.
xor challenge base string will be 0x38F371E6(decimal: 955478502)
\begin{mybox}
int temp = connid xor 0x38F371E6\\
string challenge;\\
string result;\\
for( int i=0; i<challenge.Lenth; i++ )\\
\{\\
	result+=( i + 17 + challenge[i]);\\
\}
\end{mybox}
the calculation for resopnse string is connid xor 0x38F371E6
\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline
		\textbf{Game name}&\textbf{Secret key}\\\hline
		Crysis2&8TTq4M\\\hline
	\end{tabular}
	\caption{Player authenticate response string}
	\label{Player authenticate response string}
\end{table}

\ServerResponse

\begin{mybox}[label = gstats player auth server response]
	\tbs pauthr\tbs <profile id>\tbs lid\tbs <local id>\tbs final\tbs
\end{mybox}



\section{Get Profileid}
Client can get profile id by searching his cd-key hash in GSTATS server.
\ClientRequest
\begin{mybox}
	\tbs getpid\tbs\tbs nick\tbs <nick name>\tbs keyhash\tbs<cd key hash>\tbs lid\tbs <local id>\\\tbs final\tbs
\end{mybox}

\ServerResponse

\begin{mybox}
	\tbs getpidr\tbs <profile id>\tbs lid\tbs<local id>\tbs final\tbs
\end{mybox}

\section{Get Player Data}
\ClientRequest
\begin{mybox}
	\tbs getpd\tbs pid\tbs<profile id>\tbs ptype\tbs<persist storage type>\tbs dindex\tbs <data index>\tbs keys
\end{mybox}
\ServerResponse

\begin{mybox}
\tbs getpdr\tbs <profile id>\tbs lid\tbs<local id>\tbs mod\tbs<?>\tbs length\tbs<? length>\\\tbs data\tbs <player data>\tbs final\tbs
\end{mybox}

\begin{table}
	\centering
\begin{tabular}{|l|p{8cm}|}
	\hline
	\textbf{Enum name}&\textbf{Description}\\\hline
	pd\_private\_ro& Readable only by the authenticated client it belongs to, can only by set on the server.\\\hline
	pd\_private\_rw& Readable only by the authenticated client it belongs to, set by the authenticated client it belongs to.\\\hline
	pd\_public\_ro& Readable by any client, can only be set on the server.\\\hline
	pd\_public\_rw& Readable by any client, set by the authenicated client is belongs to.\\\hline
\end{tabular}
	\caption{Persist storage enumerator}
\label{Persist storage enumerator}
\end{table}

\section{New Game}
Creates a new game for logging and registers it with the stats server. 
Creates all the game structures, including buckets if needed.
\ClientRequest

\begin{mybox}
	\tbs newgame\tbs\tbs connid\tbs<connection id>\tbs sesskey\tbs<session key>\tbs final\tbs
\end{mybox}

\ServerResponse

\begin{mybox}
	内容...
\end{mybox}

\section{Set Persist Data Helper}
\ClientRequest
\begin{mybox}
	\tbs setpd\tbs pid\tbs<profile id>\tbs ptype\tbs <persist storage type> \tbs dindex\tbs<data index>\tbs kv\tbs<key value flag>\tbs lid\tbs <local id>\tbs length\tbs<size of game defined data>\tbs final\tbs
\end{mybox}

\ServerResponse

\begin{mybox}
	\tbs setpdr\tbs<success or fail>\tbs lid\tbs<local id>\tbs pid\tbs <profile id>\\\tbs mod\tbs <modified time>\tbs final\tbs
\end{mybox}

\section{Update Game Snapshot}
\ClientRequest

Old version:
\begin{mybox}
	\tbs updgame\tbs\tbs sesskey\tbs<session key>\tbs done\tbs<final flag>\\\tbs gamedata\tbs <game data>\tbs final\tbs
\end{mybox}

New version:
\begin{mybox}
		\tbs updgame\tbs\tbs sesskey\tbs<session key>\tbs connid\tbs<connection id>\\\tbs done\tbs<final flag>\tbs gamedata\tbs <game data>\tbs final\tbs
\end{mybox}

\ServerResponse

Server only records the data.


\part{GameSpy Persist Storage}
\chapter{Introduction}
If you store your data in key\value delimited pairs, GetPersistDataValues will
allow you to easily retrieve a subset of the stored data. To retrieve the entire
data set, use GetPersistData. The data will be returned as a null-terminated string,
unless no data is available (in which case len will be 0 in the callback).
\chapter{Parameter}
\begin{itemize}
	\item localid: Your game-specific reference number for this player, returned in the callback
	to allow you to identify which player it is referring to.
	\item profileid: The profileid of the player whose data you are looking up. 
	Returned by gpIDFromProfile() in the Presence \& Messaging SDK, or using GetProfileIDFromCD
\item	type: The type of persistent data you are looking up
\item	index: Each profile can have multiple persistent data records associated with them. Usually you
	just want to use index 0.
\item	modifiedsince: A time value to limit the request for data. Data will only be returned if it has been
	modified since the time provided. If data has not been modified since that time, the callback will be
	called with a success value that indicates it is unmodified.
Note: modification time is tracked for the given profileid/index, not on a per-persisttype or per-key basis
	keys: A "\tbs" delimited list of the keys you want returned (for example: "\tbs clan\tbs color\tbs homepage\tbs birthday")
	PersDataCallbackFn: Callback that will be called with the data when it is returned
	instance: Pointer that will be passed to the callback function (for your use)
\end{itemize}




\part{GameSpy Chat Server}






\begin{appendix}
\chapter{Login Proof Challenge Generation Algorithm}\label{Login Proof Challenge Gerneration Algorithm}
\chapter{Gstats Initial Encryption}
\chapter{CDKey Server Initial Encryption}
\chapter{GameSpy Secret Key}\label{GameSpy Secret Key}
If a game is using GameSpy service, GameSpy will issue  a secret key to the game, which length is at 5-byte. The secret key that GameSpy issued is not the traditional secret key in public-key cryptography, actually it is an key for simple symmetric encryption.
\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline
		\textbf{Game name}&\textbf{Secret key}\\\hline
		Crysis2&8TTq4M\\\hline
  \end{tabular}
\caption{Secret key example}
\label{Secret key example}
\end{table}
\end{appendix}


\end{document}
