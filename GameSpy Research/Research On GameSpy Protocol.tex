\documentclass[oneside,titlepage,a4paper]{Definition/retrospy} %book,article,report,letter



\begin{document}

\title{\Huge\textbf{Research On GameSpy Protocol}} 
\author{Arves100, xiaojiuwo}


%\date{} %%如果没有这句，会生成时间

\maketitle  %%生成书名

\tableofcontents  %%生成目录

%\mainmatter %%表示文章的正文部分，在生成目录后将从第一页开始
\part{Introduction}

\chapter{History of GameSpy}

\chapter{Related Works}


\part{General Information}
In this chapter we describe the structure of GameSpy SDK and GameSpy servers.
\chapter{SDK Module}
GameSpy SDK contains of  16 modules.
	\begin{itemize}
		\item Brigades
		\item Chat
		\item Presence \& Messaging
		\item CDKey
		\item Stats \& Tracking
		\item Persistent Storage
		\item Transport
		\item NAT Negotation
		\item Peer to Peer communication
		\item Patching \& Tracking
		\item Server Browser
		\item Query \& Reporting
		\item SAKE Persistent Storage
		\item ATLAS Competition
		\item Voice Chat
		\item Web Authentication
	\end{itemize}

\chapter{GameSpy Back-end Servers}
\par GameSpy back-end servers are list as follows.
	\begin{itemize}
		\item GameSpy Presence Connection Manager (GPCM)
		\item GameSpy Presence Search Player(GPSP)
		\item GameSpy Query and Report (QR)
		\item GameSpy Server Browser (SB)
		\item GameSpy Stats \& Tracking (GStats)
		\item GameSpy Chat
		\item GameSpy NAT Negotation (NatNeg)
		\item GameSpy CDKey 
		\item GameSpy Web Services
		\item GameSpy SAKE Storage (SAKE)
	\end{itemize}

\chapter{Access Sequence of The Client}
If a user want to use GameSpy service, the access sequence is listed in Figure~\ref{The access sequence of client} and we describe the detail below.
\begin{figure}[H]
	\centering
	\scalebox{0.7}{
	\begin{tikzpicture}  [node distance = 2cm, auto,transform shape]
	\node[block] (gpcm) {GPCM};
	%%%%%%%%%%%right nodes%%%%%%%%%%
	\node[block, right= of gpcm](gpsp){GPSP};
	\node[block, right= of gpsp](qr){QR};
	\node[block, below= of qr](sb){SB};
	%%%%%%%%%%%left nodes%%%%%%%%%%%
	\node[block,below= of gpcm](cdkey){CDKey};

		%%%%%%%%%%%bottom nodes%%%%%%%%
	\node[block, below= of gpsp] (client) {Client};  
	\node[block, below= of client](gstats){GSTATS};
	\node[block, right= of gstats](webserver){WebServer};
		\node[block, left= of gstats](chat){CHAT};
	%%%%%%%%%%%top nodes%%%%%%%%%%
	\node[block, above= of gpcm](gameserver){Game Server};
	
	
	%%%%%%%%%%%lines%%%%%%%%%%%%%
	\draw[line] (client)--node [midway, above, sloped] {\circled{\small{2}}}(gpcm);
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{2}}}(gpsp);
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{3}}}(cdkey);
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{4}}}(chat);
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{1}}} (qr);
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{7}}}(sb);
	
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{5}}}(gstats);
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{5}}}(webserver);
		
	\draw[line](sb)--(qr);
	
	\draw[line](gameserver)--node [midway, above, sloped] {\circled{\small{6}}}(qr);
	\draw[line](client)--node [midway, above, sloped] {\circled{\small{8}}}(gameserver);
	\draw[line](gameserver.west) to [in=190,out=190] node [midway, above, sloped] {\circled{\small{9}}}(cdkey.west);


	\end{tikzpicture}  
}
	\caption{The access sequence of client}
	\label{The access sequence of client}
\end{figure}
\begin{flushleft}
\textbf{Explanation of access sequence}
\end{flushleft}

\begin{enumerate}
	\item Client checks in QR server, which tells client GameSpy back-end server status.
	\item Client accesses GPCM or GPSP to check their account and login.
	\item Client accesses to CDKey to verify his cd-key in login phase.
	\item Client logins to Chat server.
	\item Client retrieves player data(level, exp, etc.) from GStats(old game use this server to store player data, new game use Web Server to store player data).
	\item When a game server is launched it will send heartbeat to QR server to tell QR its information.
	\item Client accesses to SB to search online game server.
	\item Client logins to game server with his information and cd-key.
	\item Game server will check his cd-key by accessing to CDKey server, after every information is verified, client should be able to play their game.
\end{enumerate}


\chapter{Basic Description of Protocol}
In this part, we describe some of the basic patterns that are used in all GameSpy servers.

\section{String Pattern}
We first introduce the pattern of the string, which is used to make up a request and response.
The following servers do use the pattern: Presence Connection Manager, Presence Search Player, GameSpy Status and Tracking, CD-Key, Query Report(version 1)
This kind of string represents a value in a request and response sent by the client or the server as Table \ref{String pattern}.\\


\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline 
		\textbf{String}&\textbf{Description}  \\ 
		\hline 
		\tbs \textbf{key}\tbs\textbf{value}\tbs& The key is \textbf{key}, the value of the key is \textbf{value}  \\ 
 		\hline
	\end{tabular} 
	\caption{String pattern}
	\label{String pattern}
\end{table}
There are two kind of patterns the first one is value string, the second one is command string.
\textbf{Value String}
This kind of string represents a key value pair in the request or response string, it has a key and a correspond value as shown in Table~\ref{Value string}.
\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline 
		\textbf{String}&\textbf{Description}  \\ 
		\hline 
		\tbs pid\tbs  13\tbs & The key is \textbf{pid}, the value of the \textbf{pid} is 13  \\ 
		\hline
		\tbs userid\tbs  0\tbs & The key is \textbf{userid}, the value of the  \textbf{userid} is 0  \\ 
		\hline
	\end{tabular} 
	\caption{Value string}
	\label{Value string}
\end{table}


\textbf{Command String}

This kind of string represents a command in a request sends by the client or the server as Table \ref{Command string}.
The command will end with $ \backslash \backslash $ or $ \backslash $ depends on whether run at the server-side or client-side.


\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline 
		\textbf{String}&\textbf{Description}  \\ 
		\hline 
		\tbs command\tbs\tbs& This is a command \\ 		
		\hline
	\end{tabular} 
	\caption{Command string}
	\label{Command string}
\end{table}


\part{GameSpy Presence \& Messaging}
\par Presence \& Messaging system allows a game to add account authentication or registration, which includes a profile where personal information could be stored (such as email, first name), a friend list (called buddies), private messages.
\par GameSpy Presence contains two servers, GameSpy Presence Connection Manager (GPCM) and GameSpy Presence Search Player (GPSP).
GPCM is a server that manages the profiles (such as login, storing the profile information).

\chapter{Common Information}
In this section we describe the common information, methods, techniques that GPCM and GPSP have.
\section{Server IP and Ports}
Table \ref{IP and Ports for GameSpy Presence Servers} are the  IP and Ports of GPCM and GPSP that client or game connect to.
\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline 
		\textbf{Name}&\textbf{IP}&\textbf{Port}\\ 
		\hline 
		GPCM&gpcm.gamespy.com&29900 \\ 
	 	\hline 
		GPSP&gpsp.gamespy.com&29901 \\
		\hline
	\end{tabular} 
\caption{IP and Ports for GameSpy Presence Servers}
\label{IP and Ports for GameSpy Presence Servers}

\end{table}

\chapter{GameSpy Presence Connection Manager}


\section{Request Command of GameSpy Presence Connection Manager}
Table \ref{Request For GameSpy Presence Connection Manager} lists the request (known by us) that clients send to GameSpy Presence Connection Manager server (GPCM).
\begin{table}[H]
	\centering
	\begin{tabular}{B}
		\hline 
		\textbf{Commands}&\textbf{Description}  \\ 
		\hline 
		$\backslash inviteto \backslash$& Invite friends\\ 		
		\hline 
		$\backslash login \backslash$&Login to GPCM \\
		\hline
 		$\backslash getprofile \backslash$&	Get the profile of a player (including your own)\\
 		\hline
		$\backslash addbuddy \backslash$& Add a player to my friend list \\
		\hline
		$\backslash delbuddy \backslash$ & Delete a player from my friend list \\
		\hline
		$\backslash updateui \backslash$& Update login information (email, password) \\
		\hline
		$\backslash updatepro \backslash$& Update my profile such as first name, last name, gender etc. \\
		\hline
		$\backslash logout \backslash$& Logout manually by user\\
		\hline
		$\backslash status \backslash$& Update the status of a user (Such as what game is the player playing) \\
		\hline
		$\backslash ka \backslash$& Keep client or session alive \\ \hline
		$\backslash bm \backslash$& Message command \\
		\hline 
		$ \backslash blk \backslash $& Block list \\ \hline
		$ \backslash bdy \backslash $ & Friend list \\ \hline
		$ \backslash lt \backslash $& Login ticket \\ \hline
	\end{tabular} 
	\caption{Request For GameSpy Presence Connection Manager}
	\label{Request For GameSpy Presence Connection Manager}
\end{table}

Error response string for (GPCM, GPSP):
\begin{equation}
\begin{split}
\backslash error \backslash\backslash err \backslash < error code > \backslash fatal\backslash\backslash errmsg \backslash < error message > \backslash id\backslash 1 \backslash final \backslash
\end{split}	
\end{equation}

\section{GPI Connect Module}
\subsection{Login}
We show the login communication diagram in Fig~\ref{Login diagram}
\begin{figure}[H]
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPCM};
		\draw[line] ([yshift=15]b.west)--node [fill = white] {1.Send server challenge} ([yshift=15]a.east);
		\draw[line] (a.east)--node [fill = white] {2.Send client request} (b.west);
		\draw[line] ([yshift=-15]b.west)--node [fill = white] {3.Accept or reject} ([yshift=-15]a.east);
		\end{tikzpicture}
	}
\caption{Login diagram}
\label{Login diagram}
\end{figure}

\begin{flushleft}
	\textbf{Server initial Challenge:\\}
\end{flushleft}
When a client is connected to GPCM server, GPCM Server will send a challenge to client. The challenge string shows in \ref{server challenge1} and \ref{server challenge2}. However we do not know the correct functionality of \ref{server challenge2}.

\begin{mybox}[label=server challenge1]
	\tbs lc\tbs 1\tbs challenge\tbs<challenge string>\tbs final\tbs
\end{mybox}

\begin{mybox}[label=server challenge2]
	\tbs lc\tbs 1\tbs challenge\tbs<challenge string>\tbs nur\tbs\tbs userid\tbs<user id>\\
	\tbs profileid\tbs<profile id>\tbs final\tbs
\end{mybox}

\begin{itemize}
	\item{challenge: }The challenge string sent by GPCM.
\end{itemize}
\begin{table}[H]
	\centering
	\begin{tabular}{A}
		
		\hline 
		\textbf{Keys}&\textbf{Description}&\textbf{Type}  \\ 
		\hline 
		challenge & The challenge string sended by GameSpy Presence server&String \\ 		
		\hline 
		nur & ? Create new user delimiter &\\
		\hline 
		userid&The userID of the profile & Uint\\	\hline 
		profileid&The profileID & Uint\\	\hline 
	\end{tabular} 
	\caption{The first type login response}
	\label{The first type login response}	
\end{table}	

\begin{flushleft}
	\textbf{Client Login Request:\\}
\end{flushleft}
There are three ways of login:
\begin{itemize}
	\item AuthToken: Logging using an alphanumeric string that represents an user.
	\item 	UniqueNick: Logging using a nickname that is unique from all the players.
	\item User: Logging with nickname, email and password.
\end{itemize}
We show the common part of login request in \ref{Common string}

\begin{mybox}[label=Common string]
	\tbs login\tbs\tbs challenge\tbs<challenge string>\tbs $\star$\tbs userid\tbs<user id>\\
	\tbs profileid\tbs <profile id>\tbs partnerid\tbs<partner id>\\
	\tbs response\tbs<challenge response string>\tbs firewall\tbs<firewall flag>\\\tbs port\tbs<port>\tbs productid\tbs<product id>\tbs gamename\tbs<game name>\\\tbs sdkrevision\tbs<sdk revision number>\tbs quiet\tbs<quiet mode flag>\\\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}

Where the value of $ \star $ in \ref{Common string} depending on which login method user is using.

\begin{mybox}
	\tbs authtoken\tbs<authentication token>\tbs\\
	\tbs uniquenick\tbs<uniquenick name>\tbs\\
	\tbs user\tbs<nick name+@+email>\tbs
\end{mybox}
\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline
		\textbf{Keys} & \textbf{Description} & \textbf{Type}	                                                                          \\ \hline
		login& The login command which use to identify the login request of client&\\ \hline
		challenge  & The user challenge used to verify the authenticity of the client     & See \ref{Login Proof Challenge Gerneration Algorithm}                                                                                                        \\ \hline
		authtoken  & The token used to login (represent of an user)        & String\\ \hline
		uniquenick  & The unique nickname used to login       & String                                                                                                                                                                 \\ \hline
		user     & The users account (format is NICKNAME@EMAIL)           &String\\ \hline
		userid    & User id              &      Uint                                                                                                                  \\ \hline
		profileid  & Profile id          &      Uint                                                                                                                  \\ \hline
		partnerid  & This ID is used to identify a backend service logged with gamespy.(Nintendo WIFI Connection will identify his partner as 11, which means that for gamespy, you are logging from a third party connection) & Uint\\ \hline
		response   & The client challenge used to verify the authenticity of the client     & String                                                                                                                                   \\ \hline
		firewall   & If this option is set to 1, then you are connecting under a firewall/limited connection & Uint\\
		\hline
		port& The peer port (used for p2p stuff)&Uint \\\hline
		productid  & An ID that identify the game you're using            &Uint\\ \hline
		gamename   & A string that rapresents the game that you're using, used also for several activities like peerchat server identification&string \\ \hline
		
		namespaceid & Distinguish same nickname player   &Uint                                                                                                                                                                                                     \\ \hline
		sdkrevision & The version of the SDK you're using&Uint \\ \hline
		quiet    & ? Maybe indicate invisible login which can not been seen at friends list & Uint\\ \hline
		lt& The login ticket used for login into SAKE&String \\ \hline
		id& The operation number&Uint\\ \hline
	\end{tabular} 
	\caption{Login parameter string}
	\label{Login parameter string}
\end{table}


\ServerResponse

When received client's login request, server check the challenge and proof. if client pass the check, server will first send response\ref{server login response lc2} and then it will send friend list friend status, message, add friend request.

\begin{mybox}[label=server login response lc2]
	\tbs lc\tbs 2\tbs sesskey\tbs<session key>\tbs userid\tbs<user id>\tbs uniquenick\tbs <unique nick>\tbs lt\tbs<login ticket>\tbs<challenge proof>\tbs final\tbs
\end{mybox}

\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline 
		\textbf{Keys}& \textbf{Description}&\textbf{Type}  \\ 
		\hline 
		sesskey & The session key, which is a integer rapresentating the client connection&Uint \\ 		
		\hline 
		userid & The userID of the profile&Uint \\
		\hline 
		profileid&The profileID &Uint\\	\hline 
		uniquenick&The logged in unique nick &String\\	\hline 
		lt& The login ticket, unknown usage&String\\\hline
		proof& The proof is something similar to the response but it vary&String\\\hline
	\end{tabular} 
	\caption{The second type login response}
	\label{The second type login response}
\end{table}
Proof in \ref*{The second type login response} generation: $ md5(password)||48 spaces $
The user could be AuthToken or the User/UniqueNick (with the extra PartnerID).
server challenge that we received before.
the client challenge that was generated before.

\subsection{SDK Revision}

\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Login Finished};  
		\node[block,below=20pt of a] (b) {SDKRevision Check};
		\node[block,below=20pt of b] (c) {Recv Buddy Message};
		\node[block,right=20pt of c] (d) {Recv Buddy Status Info};
		\node[block,right=20pt of b] (e) {Recv Buddy Request};
		\node[block,right=20pt of a] (f) {Recv Buddy Revoke};
		\node[block,right=20pt of f]  (g) {Recv Buddy List};
		\node[block,below=20pt of g] (h) {Recv Block List};

		\draw[line] (a.south)--(b.north);
		\draw[line] (b)--(c);
		\draw[line] (c)--(d);
		\draw[line] (d)--(e);
		\draw[line] (e)--(f);
		\draw[line] (f)--(g);
		\draw[line] (g)--(h);
\end{tikzpicture}
	}
	\caption{SDK Revision process}
	\label{SDK Revision process}
\end{figure}
	When a player finished login, GPCM will check his sdkrevision, sdkrevision is an addition of each sdkrevision number. Every addition of sdkrevision number will make GPCM act differently.
\begin{mybox}
	\begin{itemize}
		\item Extended message support
		\begin{itemize}
			\item{1} GPI\_NEW\_AUTH\_NOTIFICATION = 1
			\item{2} GPI\_NEW\_REVOKE\_NOTIFICATION = 2
		\end{itemize}
		
		\item New Status Info support
		\begin{itemize}
			\item{4} define GPI\_NEW\_STATUS\_NOTIFICATION = 4
		\end{itemize}
		
		\item Buddy List + Block List retrieval on login
		\begin{itemize}
			\item{8} GPI\_NEW\_LIST\_RETRIEVAL\_ON\_LOGIN = 8
		\end{itemize}
	\item Remote Auth logins now return namespaceid/partnerid on login
	\begin{itemize}
		\item{16} GPI\_REMOTEAUTH\_IDS\_NOTIFICATION = 16
	\end{itemize}

	\item New CD Key registration style as opposed to using product ids
	\begin{itemize}
		\item{32}  GPI\_NEW\_CDKEY\_REGISTRATION = 32
	\end{itemize}

	\end{itemize}
\end{mybox}

For now, we know the sdkrevision number of GameSpy SDK test and Crysis2.


\section{GPI Buddy Module}
\subsection{Buddy Message}
The Buddy Message is a method to transmit message, buddy add request, game invite, friend revoke(friend deletion), buddy status(online status etc.).
\begin{figure}[H]
	\centering
	\scalebox{0.7}{
		\begin{tikzpicture}
		\node[block] (a) {Buddy Message}; 
		

		\node[block, right= of a](Request) {Request};
		\node[block, above= of Request] (Message) {Message};
		\node[block, above= of Message](UTM) {UTM};
		
		
		\node[block, below= of Request](Status) {Status};
		\node[block, below= of Status](Auth) {Auth};
		

		\node[block, left= of a](Invite) {Invite};
		\node[block,above= of Invite](Revoke) {Revoke};
		\node[block,below= of Invite](Ping) {Ping};
		\node[block,below= of Ping](Pong) {Pong};
		
		\draw[line] (a.west)--(Invite);
		\draw[line] (a.east)|-(Request);
		
		\draw[line] (a.west)--+(-0.5,-0.0)|-(Revoke);
		\draw[line] (a.west)--+(-0.5,-0.0)|-(Ping);
		\draw[line] (a.west)--+(-0.5,-0.0)|-(Pong);
		
		\draw[line] (a.east)--+(+0.5,-0.0)|-(UTM);
		\draw[line] (a.east)--+(+0.5,-0.0)|-(Message);
		\draw[line] (a.east)--+(+0.5,-0.0)|-(Status);
		\draw[line] (a.east)--+(+0.5,-0.0)|-(Auth);
		\end{tikzpicture}
	}
	\caption{Buddy message module}
	\label{Buddy message module}
\end{figure}
When a Buddy Message received by a client, the client will determine Buddy Message type according to Table~\ref{Buddy Message Definition}.
\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|}
		\hline 
		\textbf{Definition}&\textbf{Value} \\ 
		\hline 
 GPI\_BM\_MESSAGE&            1\\\hline
 GPI\_BM\_REQUEST     &               2\\\hline
 GPI\_BM\_REPLY        &            3  \\\hline
 GPI\_BM\_AUTH        &             4\\\hline
 GPI\_BM\_UTM            &            5\\\hline
 GPI\_BM\_REVOKE      &               6 \\\hline
 GPI\_BM\_STATUS       &          100			\\\hline			
 GPI\_BM\_INVITE           &       101\\\hline
 GPI\_BM\_PING             &      102\\\hline
 GPI\_BM\_PONG           &          103\\\hline
 GPI\_BM\_KEYS\_REQUEST        &    104\\\hline
 GPI\_BM\_KEYS\_REPLY            &   105\\\hline
 GPI\_BM\_FILE\_SEND\_REQUEST   &  200\\\hline
 GPI\_BM\_FILE\_SEND\_REPLY      &   201\\\hline
 GPI\_BM\_FILE\_BEGIN       &      202\\\hline
 GPI\_BM\_FILE\_END             &   203\\\hline
 GPI\_BM\_FILE\_DATA             & 204\\\hline
 GPI\_BM\_FILE\_SKIP          &      205\\\hline
 GPI\_BM\_FILE\_TRANSFER\_THROTTLE   &206\\\hline
 GPI\_BM\_FILE\_TRANSFER\_CANCEL&     207\\\hline
 GPI\_BM\_FILE\_TRANSFER\_KEEPALIVE &208\\\hline
	\end{tabular} 
	\caption{Buddy Message Definition}
	\label{Buddy Message Definition}
\end{table}
Because Client1 and Client2 are in NAT network, so they can not connect each other using p2p, so GPCM will forward message for them. The forward diagram shows in Figure~\ref{Buddy message diagram}
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client1};  
		\node[block,right=200pt of a] (b) {GPCM};
		\node[block,below= of a] (c) {Client2};
		\draw[line] (a)--node [fill = white] {Client buddy message} (b);
		\draw[line] (b)|-node [fill=white] {Server buddy message} (c);
		\end{tikzpicture}
	}
	\caption{Buddy message diagram}
	\label{Buddy message diagram}
\end{figure}
All Buddy Message from Client will have same prefix which we show in \ref{Client buddy message prefix}
\ClientRequest

\begin{mybox}[label=Client buddy message prefix]
	\tbs bm\tbs <buddy message type>\tbs sesskey\tbs <session key>\\
	\tbs t\tbs<profile id>\tbs date\tbs<date>\tbs$ \cdots $\tbs final\tbs
\end{mybox}



\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline 
		\textbf{Keys}& \textbf{Description}&\textbf{Type}  \\ 
		\hline 
		bm & Indicate the buddy message command, please see \ref{Buddy Message Definition}&Uint \\ 		
		\hline 
		t & Profileid of the receiver&Uint \\
		\hline 
		sesskey&The session key of the sender client&Uint\\	\hline
		msg& The message contents& String\\\hline 
	\end{tabular} 
	\caption{Client buddy message command in prefix}
	\label{Client buddy message command in prefix}
\end{table}



All Buddy Message from GPCM will have same prefix which we show in \ref{Buddy message prefix}. The contents in $ \cdots $ is different from each Buddy Message Type.
\ServerResponse

\begin{mybox}[label=Buddy message prefix]
	\tbs bm\tbs <buddy message type>\tbs f\tbs<profile id>\tbs date\tbs<date>\tbs$ \cdots $\tbs final\tbs
\end{mybox}

\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline 
		\textbf{Keys}& \textbf{Description}&\textbf{Type}  \\ 
		\hline 
		bm & Indicate the buddy message command, please see \ref{Buddy Message Definition}&Uint \\ 		
		\hline 
		f & Profileid of the sender&Uint \\
		\hline 
		date&The date that this message is sent, this value can be empty, possible format should be $ xxxxxxxx $ e.g. $ 20200201 $&Uint\\	\hline
		msg& The message contents& String\\\hline 
	\end{tabular} 
	\caption{Buddy message command in prefix}
	\label{Buddy message command in prefix}
\end{table}

Next following subsections we introduce message contents,  the message content will use in both client buddy message and server buddy message. We only write the message contents after \tbs msg\tbs.
\subsubsection{Message}
This is a general message

\begin{mybox}
	\tbs msg\tbs<message content>\tbs final\tbs
\end{mybox}


\subsubsection{UTM}

\begin{mybox}
	\tbs msg\tbs<UTM message>\tbs final\tbs
\end{mybox}


\subsubsection{Request}
This is a add friend request.
\ServerResponse

\begin{mybox}
	\tbs msg\tbs|signed|<signature>\tbs final\tbs
\end{mybox}

\subsubsection{Auth}
Auth method do not have contents after $ \backslash date \backslash $.
\subsubsection{Revoke}
Revoke method is called when a client1 deleted a client2 in his friend list. When deletion is finished in client1, client1 will send revoke message to GPCM, GPCM will forward this message to client2, then client2 will delete player1 in his friend list.
Revoke method do not have contents after $ \backslash date \backslash $.
\subsubsection{Status}\label{Buddy Status}
This is an old method for game to get status information. buddy status \ref{Buddy Status} and buddy status info \ref{Buddy Status Info} can not be used at same time. Buddy status method is a part of Buddy Message module, old game send buddy status through a buddy message.
\ServerResponse

\begin{mybox}
	\tbs msg\tbs|s|<status code>|ss|<status string>|ls|<location string>\\
	|ip|<ip address>|p|<port>|qm|<quiet mode flag>\tbs final\tbs
\end{mybox}


\subsubsection{Invite}
Invite method is used to invite a player to a game which is currently playing by another player.

\ClientRequest

\begin{mybox}
	\tbs msg\tbs|p|<product id>|l|<location string>\tbs final\tbs
\end{mybox}



\subsubsection{PING}
Ping method maybe is used to check the ping to other player. 
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client1};  
		\node[block,right=150pt of a] (b) {GPCM};
		\node[block, below= of a] (c) {Cilent2};
		
		\draw[line] ([yshift=8]a.east)--node [fill = white] {1.Send PING request} ([yshift=8]b.west);
		
		\draw[line] ([xshift=-16]b.south)|-node [fill = white] {2.Forward PING request} ([yshift=8]c.east);
		
		\draw[line] ([yshift=-8]c.east)-|node [fill = white] {3. Send Pong Response} ([xshift=16]b.south);
		
		\draw[line] ([yshift=-8]b.west)--node [fill = white] {4.Forward PONG response} ([yshift=-8]a.east);
		\end{tikzpicture}
	}
	\caption{PING and PONG diagram}
	\label{PING and PONG diagram}
\end{figure}

\ClientRequest

\begin{mybox}
	\tbs msg\tbs\tbs final\tbs
\end{mybox}

\subsubsection{PONG}

\ServerResponse

\begin{mybox}
	\tbs msg\tbs 1\tbs final\tbs
\end{mybox}

\subsection{Buddy Status Info}\label{Buddy Status Info}
This is a new method used in new game. \ref{Buddy Status} is an old method used in old game. Currently we can not tell you which game use new method and which use old method.


\ServerResponse

\begin{mybox}[label=Buddy status info string]
	\tbs bsi\tbs\tbs state\tbs <buddy status>\tbs profile\tbs<profileid>\tbs bip\tbs<buddy ip>\\
	\tbs bport\tbs<buddy port>\tbs hostip\tbs <host ip>\tbs hprivip\tbs<host private ip>\\
	\tbs qport\tbs<query port>\tbs hport\tbs<host port>\tbs sessflags\tbs<session flags>\\
	\tbs rstatus\tbs<rich status>\tbs gameType\tbs<game type>\tbs gameVnt\tbs<game variant>\tbs gameMn\tbs<game map name>\tbs product\tbs<productid>\\
	\tbs qmodeflags\tbs<quiet mode flags>\tbs final\tbs
\end{mybox}

\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline 
		\textbf{Keys}& \textbf{Description}&\textbf{Type}  \\ 
		\hline 
		bsi & buddy status info command & \\ 		
		\hline 
		state & Buddy status state&Enum \\
		\hline 
		profileid&The profileID &Uint\\	\hline 
		bip& Buddy ip &String\\	\hline 
		bport&Buddy port&Uint\\\hline
		hostip& Host ip&String\\\hline
		hprivip&Host private ip&String\\\hline
		qport&Query port&Uint\\\hline
		hport&Host port&Uint\\\hline
		sessflags&Session flag&Uint\\\hline
		rstatus&Rich status ?&String\\\hline
		gameType&Game type&String\\\hline
		gameVnt&Game variant&String\\\hline
		gameMn&Game map name&String\\\hline
		product&Productid&uint\\\hline
		qmodeflags&Quiet mode flag&Enum\\\hline
	\end{tabular} 
	\caption{Buddy status info keys}
	\label{Buddy status info keys}
\end{table}

\subsection{Buddy List}
Buddy list is a list which contains your friends.
GPCM server will send buddy list when a client is logged in. Process is showing in Fig~\ref{Buddy List} and the response is showing in \ref{Buddy list string}.
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPCM};
		\draw[line] (b)--node [fill = white] {Send Buddy List} (a);
		\end{tikzpicture}
	}
	\caption{Buddy List}
	\label{Buddy List}
\end{figure}

\ServerResponse

\begin{mybox}
	\label{Buddy list string}
	\tbs bdy\tbs<number of profileid>\tbs list\tbs<profileid 1>,
	\\<profileid 2>,$ \cdots $,<profileid n>\tbs final\tbs
\end{mybox}


\subsection{Block List}
Block list is an list which contain the players you do not like.
GPCM server will send block list when a client is logged in. Process is showing in Fig~\ref{Block List} and the response is showing in \ref{Block list string}.
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPCM};
		\draw[line] (b)--node [fill = white] {Send Block List} (a);
		\end{tikzpicture}
	}
	\caption{Block List}
	\label{Block List}
\end{figure}

\ServerResponse

\begin{mybox}[label=Block list string]
\tbs blk\tbs <number of profile id>\tbs list\tbs<profileid 1>,<profileid 2>,$ \cdots $,\\<profileid n>\tbs final\tbs
\end{mybox}

\subsection{Add Buddy}
When a client want to add another client into his buddy list. He will send the following request to GPCM.

\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client1};  
		\node[block,right=200pt of a] (b) {GPCM};
		\node[block, below= of a] (c) {Cilent2};
		
		\draw[line] (a.east)--node [fill = white] {1.Send addbuddy request} (b.west);
		
		\draw[line] (b.south)|-node [fill = white] {2.Translate addbuddy to bm request} (c.east);

		\end{tikzpicture}
	}
	\caption{Add friend diagram}
	\label{Add friend diagram}
\end{figure}

\ClientRequest

\begin{mybox}
	\tbs addbuddy\tbs\tbs sesskey\tbs<session key>\tbs newprofileid\tbs<profile id>\\
	\tbs reason\tbs<add friend reason>\tbs final\tbs
\end{mybox}

\subsection{Delete Buddy}
When a client want to delete a friend in his buddy list. He will send the following request to GPCM.
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client1};  
		\node[block,right=200pt of a] (b) {GPCM};
		\node[block, below= of a] (c) {Cilent2};
		
		\draw[line] (a.east)--node [fill = white] {1.Send delbuddy request} (b.west);
		
		\draw[line] (b.south)|-node [fill = white] {2.Translate delbuddy to bm revoke} (c.east);
		
		\end{tikzpicture}
	}
	\caption{Delete friend diagram}
	\label{Delete friend diagram}
\end{figure}
\ClientRequest

\begin{mybox}
	\tbs delbuddy\tbs\tbs sesskey\tbs <session key>\tbs delprofileid\tbs <profile id>\tbs final\tbs
\end{mybox}


\section{GPI Info Module}
\subsection{Profile}
\subsubsection{Get Profile Information}
Find a user's profile information.
\ClientRequest

\begin{mybox}
	\tbs getprofile\tbs\tbs sesskey\tbs <session key>
	\tbs profileid\tbs <profile id>\\\tbs id\tbs <operation id>\tbs final\tbs
\end{mybox}
\ServerResponse

\begin{mybox}
	\tbs pi\tbs\tbs profileid\tbs <profile id>\tbs nick\tbs <nick name>\\\tbs uniquenick\tbs <uniquenick>\tbs email\tbs<email>\tbs firstname\tbs<first name>\\
	\tbs lastname\tbs <last name>\tbs icquin\tbs<icquin>\\
	\tbs homepage\tbs<home page URL>\tbs zipcode\tbs<zip code>\\
	\tbs countrycode\tbs<country code>\tbs lon\tbs <longitude>\tbs lat\tbs<latitude>\\
	\tbs loc\tbs<location>\tbs birthday\tbs<birthday>\tbs sex\tbs<gender>\\
	\tbs pmask\tbs<public mask>\tbs aim\tbs<aim name>\tbs pic\tbs <picture>\\
	\tbs occ\tbs<occupation id>\tbs ind\tbs<industry id>\tbs inc\tbs<income id>\\
	\tbs mar\tbs<married id>\tbs chc\tbs<child count number>\tbs i1\tbs<interest 1>\\
	\tbs  o1\tbs<ownership 1>\tbs conn\tbs<connection type id>\\
	\tbs sig\tbs<peer to peer signature>\tbs id\tbs <operation id>\tbs final\tbs
\end{mybox}

Keys in profile module:
\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|}
		\hline 
		\textbf{Key}&\textbf{Description} \\ 
		\hline 
		cpubrandid&            cpu barand id\\\hline
		cpuspeed& cpu speed\\\hline
		memory&memory\\\hline
		videocard1ram& GPU memory size\\\hline
		videocard2ram& GPU memory size\\\hline
		connectionid&connection id\\\hline
		connectionspeed&connection speed\\\hline
		hasnetwork& unknow\\\hline
		passwordenc& encrypted password\\\hline
	\end{tabular} 
	\caption{Other keys in profile}
	\label{Other keys in profile}
\end{table}

\subsubsection{Update Profile Information}
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPCM};
		\draw[line] (a)--node [fill = white] {Send update profile request} (b);
		\end{tikzpicture}
	}
	\caption{Update profile diagram}
	\label{Update profile diagram}
\end{figure}
\ClientRequest

\begin{mybox}[label = update profile request]
	\tbs updatepro\tbs\tbs sesskey\tbs<session key>\tbs $\star$\tbs partnerid\tbs<partner id>\\\tbs final\tbs
\end{mybox}
The $\star$ in \ref{update profile request} is the profile information key and value pairs such as\textbf{ \tbs nick\tbs<nick name>\tbs}, etc.
\subsubsection{Update User Information}
\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPCM};
		\draw[line] (a)--node [fill = white] {Send update profile request} (b);
		\end{tikzpicture}
	}
	\caption{Update user diagram}
	\label{Update user diagram}
\end{figure}
\ClientRequest
The $\star$ in \ref{update user request} is the profile information key and value pairs such as \textbf{\tbs passwordenc\tbs<encrypted password>\tbs}, etc.
\begin{mybox}[label = update user request]
	\tbs updateui\tbs\tbs sesskey\tbs<session key>\tbs $\star$\tbs final\tbs
\end{mybox}



\subsection{GPI Profile Module}

\subsubsection{Create New Profile}
Create a new profile with nick name.
\ClientRequest

\begin{mybox}
	\tbs newprofile\tbs\tbs sesskey\tbs <session key>\tbs nick\tbs <nick name>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}
\subsubsection{Replace Existed Profile}
Replace nick name in a profile with a new nick name.
\ClientRequest

\begin{mybox}
\tbs newprofile\tbs\tbs sesskey\tbs <session key>\tbs nick\tbs <old nick name>\tbs replace\tbs 1\\\tbs oldnick\tbs<nick name>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}

\subsubsection{Delete Profile}
\ClientRequest

\begin{mybox}
	\tbs delprofile\tbs\tbs sesskey\tbs<session key>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}
\ServerResponse

\begin{mybox}
	\tbs dpr\tbs final\tbs
\end{mybox}



\subsection{GPI Unique Module}

\subsubsection{Register Unique Nick}
This method will register a new unique nick. There are two request \ref{register uniquenick1} and \ref{register uniquenick2}. The first one is only register unique nick, and the second one is register unique nick with cd key.
\ClientRequest
\begin{mybox}[label=register uniquenick1]
	\tbs registernick\tbs\tbs sesskey\tbs<session key>\tbs uniquenick\tbs<unique nick>\\\tbs partnerid\tbs<partner id>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}
\begin{mybox}[label=register uniquenick2]
	\tbs registernick\tbs\tbs sesskey\tbs<session key>\tbs uniquenick\tbs<unique nick>\\\tbs cdkey\tbs<cd key>\tbs partnerid\tbs<partner id>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}

\ServerResponse
\begin{mybox}
	\tbs rn\tbs final\tbs
\end{mybox}


\subsubsection{Register CD Key}
\ClientRequest
\begin{mybox}
	\tbs registercdkey\tbs\tbs sesskey\tbs<session key>\tbs partnerid\tbs <partner id>\tbs id\tbs <operation id>\tbs final\tbs
\end{mybox}
\ServerResponse
\begin{mybox}
	\tbs rc\tbs final\tbs
\end{mybox}

\subsection{GPI Transfer Module}



\chapter{GameSpy Presence Search Player}
GPSP server provides search function for client.\\
Table \ref{IP and Ports for GameSpy Presence Servers} are the GPSP IP and Ports that client/game connect to.

\begin{figure}[H]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}
		\node[block] (a) {Client};  
		\node[block,right=200pt of a] (b) {GPSP};
		\draw[line] ([yshift=8]a.east)--node [fill = white] {1.Send client search request} ([yshift=8]b.west);
		\draw[line] ([yshift=-8]b.west)--node [fill = white] {2.Send search result} ([yshift=-8]a.east);
		\end{tikzpicture}
	}
	\caption{GPSP diagram}
	\label{GPSP diagram}
\end{figure}

\subsection{Search User}
\ClientRequest 

\begin{mybox}
	\tbs search\tbs\tbs sesskey\tbs<session key>\tbs profileid\tbs <profile id>\tbs nick\tbs<nick name>\tbs uniquenick\tbs<unique nick name>\tbs email\tbs<email>\tbs gamename \tbs<game name>\tbs final\tbs
\end{mybox}


\ServerResponse

\begin{mybox}
	\tbs bsr\tbs<profile id>\tbs nick\tbs<nick>\tbs final\tbs
\end{mybox}

\subsubsection{User Creation}
This commmand \ref{Create user command} is used to create a user in GameSpy.
\begin{tcolorbox}
	\begin{equation}\label{Create user command}
	\begin{split}
	&\backslash newuser \backslash email \backslash < email > \backslash nick \backslash < nick > \\
	& \backslash passwordenc \backslash < passwordenc > 
	\backslash productid \backslash < productid > \\
	& \backslash gamename \backslash < gamename > \backslash uniquenick \backslash < uniquenick > \\
	& \backslash cdkeyenc \backslash < cdkeyenc > \backslash partnerid \backslash < partnerid > \backslash id \backslash 1 \backslash final \backslash
	\end{split}	
	\end{equation}
\end{tcolorbox}

The description of each parameter string is shown in Table \ref{User creation string}.
This is the response that server sends to client:
\begin{tcolorbox}
\begin{equation}
	\begin{split}
	&\backslash bsr \backslash <profileid> \backslash nick \backslash <nick>	\backslash uniquenick \backslash <uniquenick> \\
	&\backslash namespaceid \backslash <namespaceid>\backslash firstname \backslash <firstname> \\ 
	&\backslash lastname \backslash <lastname>\backslash email \backslash <email> \\
	&\backslash bsrdone \backslash <gamespy enc determinator> \backslash final \backslash
	\end{split}
\end{equation}
\end{tcolorbox}

\part{Persistent Storage}
\part{Transport}
\part{NAT Negotation}
Three matchup servers: natneg1. natnet2. natneg3.

IP: natneg1.gamespy.com or natneg2.gamespy.com or natneg3.gamespy.com
Protocol: UDP
Port: 27901

Nat Negotiation mechanism:
Because the ip address and other environment are changing from time to time, so when a client1 wants to connect
to client2, he dose not know any informations about client2, so he cannot connect to client2. using natneg it can ask client2 information on gamespy nat server and connect to client2.

The Nat Negotiation do the following things:
1.connect to GameSpy nat server
2.send the data that contain all information about himself to gamespy nat server
3.GameSpy Nat server store clients information.
4.when a client1 is try to connect to other client2:
(1) client1 send request to gamespy nat server
(2) gamespy nat server send the information about client2 to client1
(3) client1 get the client2 information and connect.

1. Client discovers if the servers are reachable
sends the following data

\begin{tcolorbox}
typedef struct \_InitPacket\\
\{\\
	unsigned char porttype;\\
	unsigned char clientindex;\\
	unsigned char usegameport;\\
	unsigned int localip;\\
	unsigned short localport;\\
\} InitPacket;\\

\#define REPORTPACKET\_SIZE BASEPACKET\_SIZE + 61\\
typedef struct \_ReportPacket\\
\{\\
	unsigned char porttype;\\
	unsigned char clientindex;\\
	unsigned char negResult;\\
	NatType natType;\\
	NatMappingScheme natMappingScheme;\\
	char gamename[50];\\
\} ReportPacket;\\

\#define CONNECTPACKET\_SIZE BASEPACKET\_SIZE + 8\\
typedef struct \_ConnectPacket\\
\{\\
	unsigned int remoteIP;\\
	unsigned short remotePort;\\
	unsigned char gotyourdata;\\
	unsigned char finished;\\
\} ConnectPacket;\\

\#define BASEPACKET\_SIZE 12\\
\#define BASEPACKET\_TYPE\_OFFSET 7\\
typedef struct \_NatNegPacket \\
\{\\
	// Base members:
	unsigned char magic[NATNEG\_MAGIC\_LEN];\\
	unsigned char version;\\
	unsigned char packettype;\\
	int cookie;	\\
	
	union \\
	\{\\
		InitPacket Init;\\
		ConnectPacket Connect;\\
		ReportPacket Report;\\
	\} Packet;\\
	
\} NatNegPacket;


\end{tcolorbox}





Magic: 0xFD 0xFC 0x1E 0x66 0x6A 0xB2
Version: 0x03

Command 1: Natify Request (0x12)
Cookie: htonl(777)

Sets Packet Init. portType to 1 if Natneg server is natneg1, 2 if it's natneg2, 3 if it's natneg3

Command 2: Address check (discover mapping)

Sets portType to as the same as Command 1
Cookie is htonl(0 for natneg1 (map1A), 1 for natneg2, 2 for natneg3, 3 for natneg1 second map (Map1B))

\part{Peer to Peer communication}
\part{Patching \& Tracking}
\part{Query \& Reporting}
Custom keys are used to define custom data to report, for example if the user is playing with a
Windows or Machintosh PC.

There could be two types of custom keys:
Player keys (they end with \_):
Custom player information
Team keys (they end with \_t):
Custom team (or brigade) information
Server keys (they don't end with anything):
Custom server information

Custom keys starts from 50 to 253


IP: gamename.master.gamespy.com
Port 27900
Protocol: UDP

There is more than one Query report ports, if 27900 is not found the system will 
try to scan the ports up to 28000

A dedicated server sends some information data to GameSpy Master Server to let GameSpy know
that a new server was started, so users can find the server in the server browser
like GameSpy 3D or GameSpy Arcade.

A server needs to be registred to GameSpy master Server, it's done with a challenge
Sending the heartbeat challenge packet and processing the response.
If an error happens, the AddError packet is sended.

A. Heartbeat (Only done if the server is public)
The heartbeat checks if the dedicated server is active or not.
When a dedicated servers sends a data, the time when the data is sended is saved in the Master server.
If the Master server does not receive a new data in 10 seconds, Master server removes the dedicated server
to the list and assumes the server is offline.

The dedicated server have to send the heartbeat packet each 10 seconds in order to maintain his connection
alive.

The Instance key is a random 4 bytes array characters generated by the client when it tries
to connect to the server

The heartbeat communicates everything new it happends to the server, like someone connected or similar.
\\
Keep alive packet:
A 5 bytes buffer composed by
0x08 (The packet id)
Instance key
\\
3 types of heartbeat packets
Type 3: Challenge heartbeat
Type 2: A server is shutting down
Type 1: User requested a change in the game data
Type 0: Normal heartbeat
\\
General heartbeat packet:

0x03 (The Packet ID)
Instance key
\\
A key represents the information of a data, much like a Dictionary (Similar to GPSP, but it uses $\backslash$0 rather than $\backslash\backslash$) 
\\
List of known keys:
localipX (Where X is the number of local IP starting from 0): Local IP of the server
localport: Query port binded by the server, where the Master Server can connect to
natneg: If you can nat negotiate with the server (If you do, the keep alive packet will also be sended)
statechanged: Integer (Type of heartbeat, see above)
gamename: Name of the game
\\
If the server want to track the local clients public ip, also this two extra parameters will be sended:
publicip: Public IP of the server
publicport: Public port
\\
The custom keys are now added with their respective value
Server, Player and Team
\\

NOTE: In the heartbeat, we are always querying the current known keys, so
rather than being "customkey\_one$\backslash$0customkey\_one\_data$\backslash$0" it's just "customkey\_one$\backslash$0$\backslash$0"
\\
(Each key is delimited by $\backslash$0)
\\
B. Check queries (Process any new query)
\\
We receive some data from the server.
\\
CD-Key query:
They start with 0x3B, nothing else is known
See CD-KEY Reverse for more information
\\
Query Report 1 queries (compatibility):
They start with $\backslash$
\\
Nat Negotiation query:
If the length is bigger than 6 and we find the NatNeg magic data
See NatNeg Reverse for more information
\\
Query Report 2:
If the first two bytes are 0xFE and 0xFD
\\
Query Report 2 Queries:
Structure:
Byte \[0\] = 0xFE
Byte \[1\] = 0xFD
Byte \[2\] = Packet type
Byte \[3-10\] = Request key (An array long 7 bytes)
\\
After all the queries are processed, the dedicated server sends back some data.
Which can be the challenges or something different.


Packet types:

Query (0x00)
This packet verify the IP of the client by checking if the random data
it was sended before (With 0x09) is the same. If it isn't the server won't
verify the client.

The dedicated server will send a notification to the Master Server about who
authenticated and who didn't

A character from the start of the data is called EXFlags and they are used to see if the QR2
server supports different things (an example is: Split if the server supports splitting the queries)

Maximum of 7 queries can be splitted

How a query is created:
A key called splitnum is created which contains the current number of key splitted
The key type (server, team or player)
The key data

Challenge (0x01)
This packet is used for verify the server with the master server.

Calculate the challenge:
First the backend option, each server can have some custom backend option, like disabling the Query Report challenge
The data sended is the following:

\[2 Bytes that are the backend option with a \backslash 0\] \\
\[Public IP (Length of 8, readed with htonl) and Port (length of 4)\]\\
\[ Max of 64 bytes containg a random data that will be the challenge, this is much like GPCM \]\\

Algorithm of calculating the challenge (Client side):

See qr2.c at line 785 (compue\_challenge\_response) for more information
A. Encrypt the challenge with the secret key
B. Encode the encrypted challenge

Echo (0x02)
Simply reply the same data as the server sended

The first byte is 0x05
Then the data the server sended (max 32 bytes are allowed)

Heartbeat (0x03)
Check "General heartbeat packet"

Add Error (0x04)
The master server sends an error to the dedicated server
For example about Server registration (Failed challenge)

Echo response (0x05)
This is a response of the Echo packet that Server sended to Client
Server to Client ID is 0x02, Client to Server ID is 0x05

Client Message (0x06)
Sends the following data (After the packet structure)

The first byte is 0x07 (Message ACK)
The other 4 bytes is the length of the message key

There can be sent a Nat negotiation packet now (With the natneg magic)
Or it can be a normam data

Max 10 messages to track

0x07???

Keep alive (0x08)
Ignored packet

Prequery IP Verify (0x09) [Server to Client only]
Try to verify the IP of a client that connects to the server.
This is only done if the user enable the IP challenge.
Each new client has to verify themself with a challenge.

A new key is added to the data to send:



%CD-Key/NatNeg authentication to QR2:
%Client ------> Query Report 2 ------> CD-Key/NatNeg Server -----> Query Report 2 (Filtered with CD-KEY or NatNeg Request) -----> Client

\part{Server Browser}
%UDP and ICMP sockets
%
%Connect to: ms<index>.gamespy.com:28910 (TCP)
%Where index is the index of the server, up to 20 multiple servers are supported.
%
%NOTE: Strings are null terminated
%
%Connect request:
%First three bytes: Message ID (0x00), length of the data (done with htons)
%Data:
%0x01 (Protocol version)
%0x03 (Encoding version)
%int32 (Unknown, should be 0, called queryFromVersion in the SDK)
%string[36] (Server returned for this game name)
%string[36] (The current game name)
%string[8] (Challenge)
%Server filter (char* with 0x0 at the end)
%Field list (char* with 0x0 at the end)
%int32 (Options, done with htonl)
%If we are using an alternative source ip:
%int32 (server IP with htonl)
%If we limit the results we can get
%int32 (max servers to see)
%
%
%Response is a Query Report 2 query:
%First byte is 0x00 for a normal response
%First byte is 0x09 for a challenge response
%
%From byte 2 to 5 there are some skipped bytes (Request key)
%
%If the client is expecting a Query Challenge, it sends a normal IP verify query (See QR2 research)
%Otherwise it sends a normal Query to QR2 with Split packets support
%It could request all keys or a basic query with not player or team queries and just some server queries
%
%
%When A client request a server:
%
%Request  :: Client (GameSpy 3D) -------> Server Browser (TCP 28910) --------> Query Report 2 Server (UDP 27901)
%Response :: Query Report 2 ------> Server Browser (Parse the QR2 data, filter it) -----> Client
%
%The server browser is like a high-level Query Report 2 server, it helps creating a server browser without having to
%do everything manually on the Query Report. An interpreter server for QR2.
%
%Get Server rules (Client request) from Server Browser server:
%First two bytes, htons(message length)
%Third byte: 0x01 (Server Info request)
%4 bytes: IP of server
%2 bytes: Port of server
%
%Send Message to the Server:
%First two bytes, htons(message length)
%Third byte: 0x02 (Send Message request)
%4 bytes: IP
%2 bytes: Port
%
%After this is done, the client sends the message (null terminated) to the Master Server (Server Browser server)
%
%Send NatNeg cookie to server:
%This just do a normal Send message to server function (see above)
%But the data is sended is a natneg request:
%First 6 bytes: NatNeg 6 magic (0xFD, 0xFC, 0x1E, 0x66, 0x6A, 0xB2)
%4 bytes for the cookie (htonl(cookie))
%
%
%Send MapLoop request:
%First two bytes, htons(message length)
%Third byte: 0x04 (MapLoop request)
%4 bytes: Public IP of server
%2 bytes: Public Port of server
%
%Send PlayerSearch request:
%First two bytes, htons(message length)
%Third byte: 0x05 (PlayerSearch request)
%4 bytes: Search option (htonl(searchOptions))
%4 bytes: Max result
%Null terminated string containing the name
%
%
%Server Browser responses:
%Main data (Or Server data):
%All data is crypted with GOA (Or Query Report 1 Server) algorithm for the cryptation key that is:
%Secret QR2 key + Challenge + Server Challenge		
%sb_serverlist.c line 797
%
%Data sended from server, header of crypted data:	
%[Length of Data] [Game Flags] [Data] [Length of Key] [Key Data]
%Byte 0: Length of the data (The length is XORed with 0xEC)
%Byte (Length of data - 1): Key length (Xored with 0xEA)
%The key data is used to decrypt the data
%Byte 1-2: Game flags (Setted by the dedicated server) and used htons
%The data is decrypted with GOA (QR1 Cryptation)
%
%Fixed Header (First 6 bytes of decrypted data):
%[Public IP] [Default port]
%PublicIP of the client requesting: 4 bytes
%Default port of the client requesting: 2 bytes (if it's 0xFFFF then there was an error)
%
%Error Data: It's contained after the fixed header to the end, null terminated
%Data:
%[Key List] [Unique Value List] [Server list]
%
%Key List:
%[Length of keys] [KeyInfo] [KeyInfo 2] [...]
%Length of keys: One byte (Max 255 Key infos)
%Key Info:
%[Key length] [Key Name] [Key Type]
%Key length: One byte
%Key name: Null terminated at the end
%
%Types of keys:
%0x01: KeyInfo byte (value length is 1)
%0x02: KeyInfo short (value length is 2)
%0x00: KeyInfo string
%The first byte is the index, if it's 0xFF then it's a null terminated string
%otherwise we already have the length when we parsed the keys
%
%
%Unique Value List:
%[Length of unique values] [Unique value] [Unique Value 2] [....]
%Length of uvalues: One byte (Max 255 unique values)
%Unique value: Null terminated string
%
%
%Server list:
%[Server Info] [Server Info 2] [...] [Last Server Info]
%
%Server Info:
%[Flags] [IP] [Port (Optional)] [Server Data (Optional)]
%Flags: One byte, if bit 5 of flags is setted (flags | 16), then the server does not use a default game port
%So, after the IP, The port data will be setted
%IP: 4 bytes containing the IP
%Port: 2 bytes
%
%Server Data:
%[Private IP] [Private Port] [ICMP IP] [KeyInfo...]
%If bit 2 of flags is setted, then we have the Private IP of the server
%The private IP length is 4
%
%If bit 6 is setted, the server uses a custom private port (not the default one)
%Private port length is 2
%
%If bit 4 is setted, the server have an ICMP server used
%ICMP IP length is 4
%
%If bit 7 is seteted, the server have some custom keys
%The length was setted when we where parsing the Key List data
%
%
%If bit 8 is setted, then we have the game full rules
%All the strings inside the full game rules are null terminated
%[Rule 1] [Rule 2] [...]
%
%
%Second data sended: AdHoc data (After the server/main data)
%This data is not crypted
%
%The first two byes is the message length (then htohs)
%The message can be at maximum 4096.
%
%The third byte is the message type
%Type 1: Push keys
%Add some keys to the server browser client
%The first character is the number of keys (max 255 keys)
%
%The keys follows the structure of KeyInfo
%
%Type 2: Server message
%Works the same as Server Info
%
%Type 3: Keepalive message
%All data the server sends it's replied back
%
%Type 4: Delete server
%[Server IP] [Server Port]
%Server IP: 4 bytes
%Server Port: 2 bytes (NOT OPTIONAL)
%
%Type 5: Maploop (Used when a new map needs to be selected)
%[Server IP] [Server Port] [Time] [Map Count] [Map Data] [Map Data 2...] [...]
%Server IP: 4 bytes
%Server Port: 2 bytes (NOT OPTIONAL)
%Time: 4 bytes (time_t)ntohl(time) rapresentation
%Map Count: One byte telling the number of maps avaiable
%Map Data: Null terminated string
%
%Type 6: Player Search
%[Is Final] [Result Count] [PlayerSearch Data] [PlayerSearch Data 2] [...]
%Is Final: 1 byte, when setted to 1, means the research is finished
%When setted to 0, the client have to expect another Type 6 adhoc packet
%Result Count: 1 byte telling the numbers of result that the playersearch produced
%
%PlayerSearch Data:
%[Nickname] [IP] [Port] [LastSeen] [Game name]
%Nickname: Null terminated string
%IP: 4 bytes
%Port: 2 bytes (not optional)
%Last Seen: 4 bytes, (time_t)ntohl(lastSeen)
%Game name: A null terminated string
%
%
%Get LAN server list:
%Client binds a socket that will be used for communicating with QR2 (Also multihomed support)
%Client sends a QR2 query request with ID 0x02 and 4 extra bytes (Called echo request) to Server Browser
%
%The QR2 socket is a broadcast socket
%
%When you create a  dedicated server in your lan, by using Query Report 2, GameSpy SB SDK discovers all
%dedicated servers opened in your network, if the dedicated servers reply the QR2 Echo Packet
%
%---------------------------------------------------- Master Server: ICMP -----------------------------
%
%Discovered with the SDK, we know that ICMP support can be disabled.
%It is confirmed to be used in platforms like PlayStation2.
%
%What server to connect?
%- If the Server (in the serverbrowser ServerData) define a custom ICMP IP, then connect to that
%- Otherwise, connect to the Public IP of the server
%
%Everything looks the same as ServerBrowsing reverse, the different seems to be that
%we can parse data not only from the Query socket (UDP) but from the ICMP socket
%
%Platforms that doesn't use ICMP:
%- Linux or any other Unix based distribution (like FreeBSD)
%- MacOSX
%- iPhone
%- Nintendo DS
%- Nintendo Wii
%
%The data follows a usual ICMP protocol: https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol
%Look at sb/sb_internal.h for more information about SBICMPHeader.
\part{SAKE Persistent Storage}
\part{ATLAS Competition}
\part{Voice Chat}
\part{Web Authentication}

\part{GameSpy Status \& Tracking}
when game connect to GSTATS server, server will send an message to game which contains the challenge, the total length of message must bigger than 38bytes, and the challenge must bigger than 20bytes.
when game received the challenge it will compute a response, the response is formed as follows. 
response = CRC32(<server challenge>,<length of server challenge>)||<game secret key>
then game will compute the MD5 hash as MD5value = MD5(<response>,<length of response>)
then encoded with Enctype3
then construct the challenge-response message as $ \backslash auth \backslash \backslash gamename \backslash <gamename>\backslash response \backslash <MD5value> \backslash port \backslash <port> \backslash id \backslash <id> $

session key length (unknown)
connction id = transfer ascii of sessionkey to integer

the initialization phase is finished.
server challenge message length (bigger than 38-byte)
server challenge length (bigger than 20-byte)
$ \backslash final \backslash $ is encrypted using XOR Enctype1 at the end of the challenge that sends by the server.

\part{Chat Server}






\begin{appendix}
\chapter{Login Proof Challenge Generation Algorithm}\label{Login Proof Challenge Gerneration Algorithm}
\chapter{Gstats Initial Encryption}
\chapter{CDKey Server Initial Encryption}
\end{appendix}


\end{document}
