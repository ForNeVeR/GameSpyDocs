--------------------------------------------------------------------------
-- Complete GameSpy Protocol
-- Start Data: Unknown (around mid-2019)
-- Last Update: 20-06-2019
-- Author: Arves100
---------------------------------------------------------------------------

------------------------------------- GameSpy Presence Server -----------------------------

IP and Ports:
gpcm.gamespy.com:29900
gpsp.gamespy.com:29901


User => An user contains the Email and the password, but contains multiple profiles
ProfileID => The profile contains the name, surname, birth date and all the rest user info, including
an unique nickname used to identify the profile and a generic nickname used to show for example in
games

Describing the protocol
The protocol works by reading the content between the "\"
\CONTENT\
The value will be CONTENT
The \\ after the first \ rapresents a command
\error\\ = error command

\id\1\ is a parameter of the command
id is the parameter name
1 is the value

Rapresentable by a dictionary with type and value (std::map or Map<String,String>)


Generic way to send an error (GPSP,GPCM):
\error\\err\ERROR CODE\fatal\\errmsg\ERROR MESSAGE\id\1\final\

\lc\ = Login command

Logging:
\lc\1
This command is send by the server when a connection is accepted, it gets the challenge
required to verify the server
Parameters:
\challenge\A server challenge (Alphanumeric string with length 10)

When a user is logging in the command login will be sended with the following content:
\login\ (NOTICE that in client commands the extra \ is not present)

There are three ways of login:
AuthToken: Logging using an alphanumeric string that rapresents an user
UniqueNick: Logging using a nickname that is unique from all the players
User: Logging with the nickname and the password

Challenge: the user challenge used to verify the authenticity of the client
authtoken: The token used to login (rapresentation of an user)
uniquenick: the unique nickname used to login
user: Format is NICKNAME@EMAIL
userid: Send the userid (for example when you disconnect you will keep this)
profileid: Send the profileid (for example when you disconnect you will keep this)
partnerid: This ID is used to identify a backend service logged with gamespy.
For example: Nintendo WIFI Connection will identify his partner as 11, which means
that, for gamespy, you are logging from a third party connection
response: The client challenge used to verify the authenticity of the client
firewall: If this option is set to 1, then you are connecting under a firewall/limited connection
port: The peer port (used for p2p stuff)
productid: An ID that identify the game you're using
gamename: A string that rapresents the game that you're using, used also for several
activities like peerchat server identification
sdkrevision: The revision of the SDK you're using
namespaceid: Unknown
quiet: ?
id: 1 (The ID of the server hardcoded as 1)

If the parnerid is different than 0 (GameSpy partnerID),
the client will ad an extra "PartnerID@" at the Response generation
THIS DOES NOT APPLY FOR AUTHTOKEN LOGIN!

The response is generated by:
Password hashed by MD5
48 spaces
The user could be AuthToken or the User/UniqueNick (with the extra PartnerID)
The client challenge that is generated before
The server challenge that we received before
Password hashed by MD5

At the end, this response is hashed to MD5

User creation:
\newuser\ (command)

email: The email used to create
nick: The nickname that will be created
passwordenc: The encoded password (password XORed by Gamespy seed and the Base64 encoded)
productid: An ID that identify the game you're using
gamename: A string that rapresents the game that you're using, used also for several
namespaceid: Unknown
uniquenick: Uniquenick that will be created
cdkeyenc: The encrypted CD key, encrypted the same as the password
partnerid: This ID is used to identify a backend service logged with gamespy.
id: 1 (The ID of the server hardcoded as 1)


Login response:
\\lc\\2:

sesskey: The session key, which is a integer rapresentating the client connection
userid: The userID of the profile
profileid: The profileID
uniquenick: The logged in unique nick
lt: The login ticket, unknown usage
proof: The proof is something similar to the response but it vary

Proof generation:
password hashed md5
48 space
The user could be AuthToken or the User/UniqueNick (with the extra PartnerID)
server challenge that we received before
the client challenge that was generated before
password hashed by MD5

---------------------------------------------------- Master Server Avaiability ---------------

IP: gamename.avaiable.gamespy.com
Port: 27900

Client SDK conterpart: common/gsAvaiable.c

This part is used to check if the GameSpy service for that specific game is avaiable.
A game that does not support gamespy anymore should return the not avaiable status.
This part is also used to check if the GameSpy service is online or offline.

The data is unencrypted and sended with a char buffer,
each data is filled inside the char buffer

Packet initialization: (Imagine something as char buffer[256])
buffer location 0: packet type (0x09)
buffer location 1-4: 0x00 for all 4
buffer location 5-X: The game name (the length is used for determinate the gamename string length) with null terminator

Response:
NOTE: The length of a response packet must be greater than 6!
The first 3 bytes MUST BE 0xFE, 0xFD and 0x09 (Header)

The next 4 bytes rapresents an integer
the 4 bytes will be byteshifted into one integer.

This integer rapresents the status of the server.

If the first bit is active (status & 1), then the server IS NOT AVAIABLE (GameSpy offline)

If the second bit is active (and not the first, status & 2), then the server IS TEMPORARILY OFFLINE
like a maintenance of the server

If bit 1 and bit 2 are not active (status & 1 < 1 && status & 2 < 1), then the server is online.

---------------------------------------------------- Game Patching ---------------------

GameSpy allowed games to check a game version and report the updates.

Client SDK counterpart: PT\ptMain.c

Patch checking:
The game connects to motd.gamespy.com with port 80.

This exchange works like a normal HTTP page, by fact GHTTP SDK is being used.

The request is:
GET /motd/vercheck.asp

This page is NOT CONTROLLED by a master server, rather the page was programmed with ASP
language and used ISS server as a backend.

The page arguments are the following
productid= the ID of the game
lockout= Unknown usage, it fills a mandatory flag if it's setted to 1
versionuniqueid= An unique identificator of the game (a string)
distid= The distribution channel (identify multiple server for downloading the patch, like EU or NA server)
gamename= The name of the game

A complete request to the page (it could also work in a browser)
GET http://motd.gamespy.com:80/motd/vercheck.asp?productid=1&versionuniqueid=1000&distid=1&gamename=TEST
(The data is random, just used to show the complete page query)

Response of the check patch works like the Presence Server (using the '\')
The response is actually the page content.

newver: the new unique version id
lockout: a mandatory flag?
fpfileid: The file id to download in case a new version is found (fp = fileplanet, used for that in the beginning)
newvername: The name of the new patch (like version 1.1)
dlurl: The URL that the patch will be downloaded

The HTTP SDK will be used to process the file download

---------------------------------------- Game Tracking -----------------------

Client SDK counterpart: PT\ptMain.c (Patching & Tracking SDK)

The client will send an HTTP GET request (like patching) to the following IP: motd.gamespy.com

Request: http://motd.gamespy.com/motd/motd.asp?userid=1&productid=1&uniqueversionid=Test Program 1.0&
distid=0&uniqueid=0&gamename=TEST

NOTE: motd.gamespy.com/motd/motd.asp could be changed!

UserID: the id of the user that will be tracked
ProductID: ID of the product
UniqueVersionID: Unique identifier of the version
DistID: Distribution channel
UniqueID: MAC Address of the Computer/Console that runs the program
GameName: The game name

If any error happens when reading the file, it means that the tracking failed.
Otherwise, the tracking will be succeeded (if it can retrive the file, no matter the content of it)

------------------------------------ Master Server Patching: Downloading files from FilePlanet ----------------

HTTP Request to:
GET http://www.fileplanet.com/dlfileraw.asp?file=3958299&gamename=TEST

file: The file ID, we recive that from "fpfileid"
gamename: the game name


---------------------------------------------- Peer SDK --------------------------------------

Peer is used for communicating between a group of peers.

For example:
 When you make a new lobby for your friends, Peer module will be used to create the lobby
  and handle the communication between you (the lobby master) and all the people logged in
  your lobby (which are the PEERs)

Peer handle the following things:
 Auto matchmaking between the peers in your lobby
 CD-KEY verification for your peers
 Pinging between the peers
 Lobby and Chat handling for your peers

The peer module USES PeerChat for doing this communication.

Each peer does have an unique ID for identifying it.

By fact a lobby in GameSpy MEANS a new chat channel (the IRC Chat channel we all know from PeerChat)

SO inviting in a lobby is basicly inviting a client to an IRC chat.

The lobby name is the IRC chat topic.

For more information on how the communication between PeerChat server and client,
please refeer to the PeerChat research document.


----------------------------------- Game statistics ---------------------------

IP: gamestats.gamespy.com : 29920

gamename.gamestats.gamespy.com => TARGET IP the client connects
Protocol: TCP

Reference: gstats/gstats.c

The server sends a challenge like GameSpy Connection Manager.

Challenge: (38 bytes long)
  The challenge is decoded with Encryption Type 1

Algorithm of decoding (as found in line 127):
  XOR each character of the buffer with the encode string you passed.
  If the encode string is smaller than the buffer, the encode string is resetted
  to it's initial position

  Example: encode string ABCD buffer: 12345678
  1 XOR A
  2 XOR B
  3 XOR C
  4 XOR D

  Encode buffer is resetted to it's initial position.

  5 XOR A
  6 XOR B
  7 XOR C
  8 XOR D

Encode 1: ameSpy3D
Encode 2: ndustries 
Encode 3: rojectAphex

How a connection to the statistics server is initialized:
1. The server sends, after the client is connected, this data:
 (Look at GameSpy presence protocol for more information, as it follows the same):
\challenge\<challenge>\

NOTE: This data must exist on the input data, but we don't know (since it's not checked)
if the server sends any other data
NOTE 2: This data is encrypted with Encode 1
NOTE 3: The \final\ is checked as usual.

2. The client response is the following:
\auth\gamename\<gamename>\response\<response data>\port\<client port>\id\1\final\

Client port is a free port on the client PC for unknown usage.
Gamename is the usual game name
Response data is an MD5 of the following string:
  CRC32 of the challenge that the server sends and the Gamespy CD secret key

  The Gamespy CD secret key is setted by the client and could (or could not be)
  unique.

3. The server sends the following data:
\sesskey\<session key>\

NOTE: the data have the same issue as before
NOTE 2: This data is encrypted with Encode 1

4. The client tries to send a local file that contains the current or new statics (saved inside a file that the developer
of the game can specify) to be sended to the server.

Statistics file format (readed as a binary file):
  Each data is composed by a request that will be sended to the server.
  Something like \custom_data\1\final\. THERE IS THE FINAL\ which tells the server where to end like an usual GPSP request

  Each line is composed by (example proof of concept structure)
  struct Line {
    int32_t check_crc;
    int32_t length;
    void* data;
  }

  1. The client reads the complete size of the file and creates a buffer (called allData in the SDK) with the length of the file + 2 (ftell(fp) + 2)
  2. The client reads the content of the line
    A. The first data readed is the CRC32 check, which is used to check if the line data is corrupted.
    B. The second data readed is the length, which is encrypted with a XOR of 0x70F33A5F (NOTE: In the SDK this is a define, so it could be different on other games) 
    C. The data is readed, the length is used to read the data.
    D. The readed data is decoded with Encryption type 2 (See upper for more information)
    E. A CRC32 of the unencrypted data is calculated and verified if it's the same CRC32 as the Check CRC32 readed before.
    F. The unecnrypted data is encrypted with Encryption type 1, ready to be sended to the server.
    G. The encrypted type1 data is appended to the buffer (allData)
3. After all lines are readed (reached a read error or EOF), the data is sended to the server.

Login to authentication server:
  There are 3 ways of authenting:
    1. Using Player ID
    2. Using CD-KEY
    3. Using AuthToken and the partner ID (used in games like Mario Kart DS)

  Client sends this data to the server (different for each method):
   Method 1: \authp\\pid\<profile ID>\resp\<response data>\lid\<local id>\final\
   Method 2: \authp\\nick\<user nickname>\keyhash\<key hash of the CD-KEY>\resp\<response data>\lid\<local id>\final\
   Method 3: \authp\\authtoken\<auth token>\resp\<response data>\lid\<local id>\final\

  Local ID and Profile ID: setted by the game
  Local ID: game-specific reference number for this player, used to identify what player is in the game
  he is currently playing

  Authentication Response data (different from the last one, and different for each authentication method):
   Method 1: MD5 of password and a generated challenge (see below).
   Method 2: MD5 of cd-key and a generated challenge (see below).
   Method 3: MD5 of partner challenge and a generated challenge (see below).

  Generation of the challenge:
    Create a string with max length 8 bytes
    Convert Connetion ID XORed with 0x38F371E6 (the result is an integer) to hexadecial and copy it to the challenge string.
    NOTE: The format is %08x (sprintf(challenge_string, "%08x", connID ^ CHALLENGE_XOR)), so if the hexadecimal data is smaller that 8, 
      extra 0 will be added at the beginning of the number until all the 8 bytes challenge string is filled up.

    Then, the string will be masked by doing the following algorithm (for each character in the string):
      The current character of the string will be added by 17 (since it's character is an integer) and add the current position of the character that we are encrypting (from 0 to 7)

    NOTE2: The XOR is a define on the SDK, so it could be different on other games.
  Server sends the following data:
    \\pauthr\\<player id>\\lid\\<local id>\\errmsg\\<any error message>\\final\\

    If the authentication failed, the player id is setted to any number lesser than 1 (Like -1) and errmsg is filled up with the
    error message at the authentication.

Getting the data from statistic server (also known as Persist Data):

There are 4 types of persistent data stored for each player:
pd_private_rw (0): Readable only by the authenticated client it belongs to, set by the authenticated client it belongs to
pd_private_ro (1): Readable only by the authenticated client it belongs to, can only by set on the server
pd_public_rw (2): Readable by any client, set by the authenicated client is belongs to
pd_public_ro (3): Readable by any client, can only be set on the server

1. Client sends the following data to the server:
\getpd\\pid\<player id>\ptype\<see above>\dindex\<data index>\keys\<data to get>\lid\<local id>\final\

Keys are used when you want to get multiple data at once.
For example: \clan\color\homepage\. (Each key is delimited by a \)
NOTE: In the request, since '\' is already reserved by the protocol (see GPCM protocol), the client
 converts the '\' from the keys to '\x1'

Modified data: A time value to limit the request for data. Data will only be returned if it has been
	modified since the time provided. If data has not been modified since that time, the callback will be
	called with a success value that indicates it is unmodified.
	Note: modification time is tracked for the given profileid/index, not on a per-persisttype or per-key basis

If the developer want to enable modified data, the request of the client will also contain:
\mod\<time_t integer rapresentation of the modificated since value>

2. Server sends teh following response:
\getpdr\<1 if success or 0 if failed>\lid\<local id>\mod\<time_t rapresention of the last time the data was modified>\length\<length of the data>\data\<the data will be processed by the client>\final\

Getting the profile id from a cd-key login

1. Client sends
\getpid\\nick\<nickname>\keyhash\<CD-KEY hash>\lid\<local id>\final\

----------------------------------- Chat server research -----------------------

PeerChat is AN IRC SERVER!
See this RFC for more information on how an IRC server works:
https://tools.ietf.org/html/rfc2813
https://tools.ietf.org/html/rfc2812
https://tools.ietf.org/html/rfc1459

There are two ways of connecting:

1. Non secure connections
2. Secure connection


A non secure connections is a direct connection to the IRC server, much like a normal
IRC client.

But GameSpy does, however, creates a secure connections when a game communicates to the
server, which is used to encrypt the data between the IRC server and the game:

This document will follow the RFC2813 for describing the commands:


Command: LOGINPREAUTH
Parameters: <authtoken> <partnerchallenge>

The LOGINPREAUTH command is sended before logging into a server.

The partner challenge is a special challenge used to indentify the 3rd party company or service
that uses GameSpy (An example of 3rd party service could be Nintendo Wifi Connection)

Example: LOGINPREAUTH GEFJEIAFJ3H84589UFJHEFH38 5820852003


Command: LOGIN

The login should corrispond to the GPCM login, by fact you can login with an Auth token (PREAUTH)
or a normal login

Parameters for normal login: <namespaceID> * <passwordHash> :<profilenick> <email>
or
Parameters for uniquenick login: <namespaceID> <uniqueNick> <passwordHash>

PasswordHash is an MD5 of the password.
NamespaceID is the namespace ID as shown in GPSP

Normal login example: LOGIN 0 * KFEOGJMIASNEFNIAEJFEIF :Arves100 arves100@gmail.com
Uniquenick login example: LOGIN 0 Arves100 KFEOGJMIASNEFNIAEJFEIF


Command: USRIP

Gets the user id of the current connection

Example: USRIP


Command: REGISTERNICK
Parameter: <namespaceID> <uniqueNick> <cdkey>

This command registers the unique nickname

Example: REGISTERNICK 0 Arves100 FEJI-JTIE-FEIF-FJIE


Command: MODE
Parameter: <nickname> +/-q

NOTE: This command is an extension of the original MODE command from IRC

Enable or disable quiet mode: if +q is sended then quiet mode is enable,
if -q is sended then quiet mode is disabled


Example: MODE Arves100 +q


Command: CDKEY
Parameter: <cdkey>

Sends the CDkey of the game

Example: CDKEY FEJI-JTIE-FEIF-FJIE


Command: PRIVMSG

NOTE: This extends the PRIVMSG command of IRC by adding an action command, which can be
used to specify an action like "Join this game"

Action message parameter: <receiver> :\001ACTION <message>\001

Example: PRIVMSG Arves100 :\001ACTION JOIN THIS\001

Command: ATM
Parameter: 

UNKOWN?

Command: UTM
Parameter:

UNKOWN?
