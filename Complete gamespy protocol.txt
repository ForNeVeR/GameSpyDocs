--------------------------------------------------------------------------
-- Complete GameSpy Protocol
-- Start Data: Unknown (around mid-2019)
-- Last Update: 28-06-2019
-- Author: Arves100
---------------------------------------------------------------------------

------------------------------------- GameSpy Presence Server -----------------------------

IP and Ports:
gpcm.gamespy.com:29900
gpsp.gamespy.com:29901


User => An user contains the Email and the password, but contains multiple profiles
ProfileID => The profile contains the name, surname, birth date and all the rest user info, including
an unique nickname used to identify the profile and a generic nickname used to show for example in
games

Describing the protocol
The protocol works by reading the content between the "\"
\CONTENT\
The value will be CONTENT
The \\ after the first \ rapresents a command
\error\\ = error command

\id\1\ is a parameter of the command
id is the parameter name
1 is the value

Rapresentable by a dictionary with type and value (std::map or Map<String,String>)


Generic way to send an error (GPSP,GPCM):
\error\\err\ERROR CODE\fatal\\errmsg\ERROR MESSAGE\id\1\final\

\lc\ = Login command

Logging:
\lc\1
This command is send by the server when a connection is accepted, it gets the challenge
required to verify the server
Parameters:
\challenge\A server challenge (Alphanumeric string with length 10)

When a user is logging in the command login will be sended with the following content:
\login\ (NOTICE that in client commands the extra \ is not present)

There are three ways of login:
AuthToken: Logging using an alphanumeric string that rapresents an user
UniqueNick: Logging using a nickname that is unique from all the players
User: Logging with the nickname and the password

Challenge: the user challenge used to verify the authenticity of the client
authtoken: The token used to login (rapresentation of an user)
uniquenick: the unique nickname used to login
user: Format is NICKNAME@EMAIL
userid: Send the userid (for example when you disconnect you will keep this)
profileid: Send the profileid (for example when you disconnect you will keep this)
partnerid: This ID is used to identify a backend service logged with gamespy.
For example: Nintendo WIFI Connection will identify his partner as 11, which means
that, for gamespy, you are logging from a third party connection
response: The client challenge used to verify the authenticity of the client
firewall: If this option is set to 1, then you are connecting under a firewall/limited connection
port: The peer port (used for p2p stuff)
productid: An ID that identify the game you're using
gamename: A string that rapresents the game that you're using, used also for several
activities like peerchat server identification
sdkrevision: The revision of the SDK you're using
namespaceid: Unknown
quiet: ?
id: 1 (The ID of the server hardcoded as 1)

If the parnerid is different than 0 (GameSpy partnerID),
the client will ad an extra "PartnerID@" at the Response generation
THIS DOES NOT APPLY FOR AUTHTOKEN LOGIN!

The response is generated by:
Password hashed by MD5
48 spaces
The user could be AuthToken or the User/UniqueNick (with the extra PartnerID)
The client challenge that is generated before
The server challenge that we received before
Password hashed by MD5

At the end, this response is hashed to MD5

User creation:
\newuser\ (command)

email: The email used to create
nick: The nickname that will be created
passwordenc: The encoded password (password XORed by Gamespy seed and the Base64 encoded)
productid: An ID that identify the game you're using
gamename: A string that rapresents the game that you're using, used also for several
namespaceid: Unknown
uniquenick: Uniquenick that will be created
cdkeyenc: The encrypted CD key, encrypted the same as the password
partnerid: This ID is used to identify a backend service logged with gamespy.
id: 1 (The ID of the server hardcoded as 1)


Login response:
\lc\2:

sesskey: The session key, which is a integer rapresentating the client connection
userid: The userID of the profile
profileid: The profileID
uniquenick: The logged in unique nick
lt: The login ticket, unknown usage
proof: The proof is something similar to the response but it vary

Proof generation:
password hashed md5
48 space
The user could be AuthToken or the User/UniqueNick (with the extra PartnerID)
server challenge that we received before
the client challenge that was generated before
password hashed by MD5

-------------------------------------- Nat Negotiation -------------------

Three matchup servers: natneg1. natnet2. natneg3.

IP: natneg1.gamespy.com or natneg2.gamespy.com or natneg3.gamespy.com
Protocol: UDP
Port: 27901

1. Client discovers if the servers are reachable
sends the following data

typedef struct _InitPacket
{
	unsigned char porttype;
	unsigned char clientindex;
	unsigned char usegameport;
	unsigned int localip;
	unsigned short localport;
} InitPacket;

#define REPORTPACKET_SIZE BASEPACKET_SIZE + 61
typedef struct _ReportPacket
{
	unsigned char porttype;
	unsigned char clientindex;
	unsigned char negResult;
	NatType natType;
	NatMappingScheme natMappingScheme;
	char gamename[50];
} ReportPacket;

#define CONNECTPACKET_SIZE BASEPACKET_SIZE + 8
typedef struct _ConnectPacket
{
	unsigned int remoteIP;
	unsigned short remotePort;
	unsigned char gotyourdata;
	unsigned char finished;
} ConnectPacket;

#define BASEPACKET_SIZE 12
#define BASEPACKET_TYPE_OFFSET 7
typedef struct _NatNegPacket {
	// Base members:
	unsigned char magic[NATNEG_MAGIC_LEN];
	unsigned char version;
	unsigned char packettype;
	int cookie;	

	union 
	{
		InitPacket Init;
		ConnectPacket Connect;
		ReportPacket Report;
	} Packet;

} NatNegPacket;


Magic: 0xFD 0xFC 0x1E 0x66 0x6A 0xB2
Version: 0x03

Command 1: Natify Request (0x12)
Cookie: htonl(777)

Sets Packet Init. portType to 1 if Natneg server is natneg1, 2 if it's natneg2, 3 if it's natneg3

Command 2: Address check (discover mapping)

Sets portType to as the same as Command 1
Cookie is htonl(0 for natneg1 (map1A), 1 for natneg2, 2 for natneg3, 3 for natneg1 second map (Map1B))


--------------------------------------- Master Server Query Report 2 ---------------------------

Custom keys are used to define custom data to report, for example if the user is playing with a
Windows or Machintosh PC.

There could be two types of custom keys:
Player keys (they end with _):
  Custom player information
Team keys (they end with _t):
  Custom team (or brigade) information
Server keys (they don't end with anything):
  Custom server information

Custom keys starts from 50 to 253

IP: gamename.master.gamespy.com
Port 27900
Protocol: UDP

There is more than one Query report ports, if 27900 is not found the system will 
try to scan the ports up to 28000

A dedicated server sends some information data to GameSpy Master Server to let GameSpy know
that a new server was started, so users can find the server in the server browser
like GameSpy 3D or GameSpy Arcade.

A server needs to be registred to GameSpy master Server, it's done with a challenge
Sending the heartbeat challenge packet and processing the response.
If an error happens, the AddError packet is sended.

A. Heartbeat (Only done if the server is public)
The heartbeat checks if the dedicated server is active or not.
When a dedicated servers sends a data, the time when the data is sended is saved in the Master server.
If the Master server does not receive a new data in 10 seconds, Master server removes the dedicated server
to the list and assumes the server is offline.

The dedicated server have to send the heartbeat packet each 10 seconds in order to maintain his connection
alive.

The Instance key is a random 4 bytes array characters generated by the client when it tries
to connect to the server

The heartbeat communicates everything new it happends to the server, like someone connected or similar.

Keep alive packet:
A 5 bytes buffer composed by
0x08 (The packet id)
Instance key

3 types of heartbeat packets
Type 3: Challenge heartbeat
Type 2: A server is shutting down
Type 1: User requested a change in the game data
Type 0: Normal heartbeat

General heartbeat packet:

0x03 (The Packet ID)
Instance key

A key represents the information of a data, much like a Dictionary (Similar to GPSP, but it uses \0 rather than \\) 

List of known keys:
localipX (Where X is the number of local IP starting from 0): Local IP of the server
localport: Query port binded by the server, where the Master Server can connect to
natneg: If you can nat negotiate with the server (If you do, the keep alive packet will also be sended)
statechanged: Integer (Type of heartbeat, see above)
gamename: Name of the game

If the server want to track the local clients public ip, also this two extra parameters will be sended:
publicip: Public IP of the server
publicport: Public port

The custom keys are now added with their respective value
Server, Player and Team

NOTE: In the heartbeat, we are always querying the current known keys, so
rather than being "customkey_one\0customkey_one_data\0" it's just "customkey_one\0\0"

(Each key is delimited by \0)

B. Check queries (Process any new query)

We receive some data from the server.

CD-Key query:
  They start with 0x3B, nothing else is known
  See CD-KEY Reverse for more information

Query Report 1 queries (compatibility):
  They start with \

Nat Negotiation query:
  If the length is bigger than 6 and we find the NatNeg magic data
  See NatNeg Reverse for more information

Query Report 2:
  If the first two bytes are 0xFE and 0xFD

Query Report 2 Queries:
  Structure:
    Byte [0] = 0xFE
    Byte [1] = 0xFD
    Byte [2] = Packet type
    Byte [3-10] = Request key (An array long 7 bytes)

  After all the queries are processed, the dedicated server sends back some data.
  Which can be the challenges or something different.

  Packet types:

    Query (0x00)
      This packet verify the IP of the client by checking if the random data
      it was sended before (With 0x09) is the same. If it isn't the server won't
      verify the client.

      The dedicated server will send a notification to the Master Server about who
      authenticated and who didn't

      A character from the start of the data is called EXFlags and they are used to see if the QR2
      server supports different things (an example is: Split if the server supports splitting the queries)

      Maximum of 7 queries can be splitted

      How a query is created:
        A key called splitnum is created which contains the current number of key splitted
        The key type (server, team or player)
        The key data

    Challenge (0x01)
      This packet is used for verify the server with the master server.

      Calculate the challenge:
        First the backend option, each server can have some custom backend option, like disabling the Query Report challenge
        The data sended is the following:

        [2 Bytes that are the backend option with a \0] [Public IP (Length of 8, readed with htonl) and Port (length of 4)]
        [ Max of 64 bytes containg a random data that will be the challenge, this is much like GPCM ]

        Algorithm of calculating the challenge (Client side):

        See qr2.c at line 785 (compue_challenge_response) for more information
        A. Encrypt the challenge with the secret key
        B. Encode the encrypted challenge

    Echo (0x02)
      Simply reply the same data as the server sended
      
      The first byte is 0x05
      Then the data the server sended (max 32 bytes are allowed)

    Heartbeat (0x03)
      Check "General heartbeat packet"
      
    Add Error (0x04)
      The master server sends an error to the dedicated server
      For example about Server registration (Failed challenge)

    Echo response (0x05)
     This is a response of the Echo packet that Server sended to Client
     Server to Client ID is 0x02, Client to Server ID is 0x05

    Client Message (0x06)
      Sends the following data (After the packet structure)

      The first byte is 0x07 (Message ACK)
      The other 4 bytes is the length of the message key

      There can be sended a Nat negotiation packet now (With the natneg magic)
      Or it can be a normam data

      Max 10 messages to track

	0x07???

    Keep alive (0x08)
      Ignored packet

    Prequery IP Verify (0x09) [Server to Client only]
      Try to verify the IP of a client that connects to the server.
      This is only done if the user enable the IP challenge.
      Each new client has to verify themself with a challenge.

      A new key is added to the data to send:



CD-Key/NatNeg authentication to QR2:
Client ------> Query Report 2 ------> CD-Key/NatNeg Server -----> Query Report 2 (Filtered with CD-KEY or NatNeg Request) -----> Client

----------------------------------------- Master Server: Server Browser -------------------------
UDP and ICMP sockets

Connect to: ms<index>.gamespy.com:28910 (TCP)
Where index is the index of the server, up to 20 multiple servers are supported.

NOTE: Strings are null terminated

Connect request:
 First three bytes: Message ID (0x00), length of the data (done with htons)
 Data:
	0x01 (Protocol version)
	0x03 (Encoding version)
	int32 (Unknown, should be 0, called queryFromVersion in the SDK)
	string[36] (Server returned for this game name)
	string[36] (The current game name)
	string[8] (Challenge)
	Server filter (char* with 0x0 at the end)
	Field list (char* with 0x0 at the end)
	int32 (Options, done with htonl)
	If we are using an alternative source ip:
	int32 (server IP with htonl)
	If we limit the results we can get
	int32 (max servers to see)


Response is a Query Report 2 query:
	First byte is 0x00 for a normal response
	First byte is 0x09 for a challenge response

	From byte 2 to 5 there are some skipped bytes (Request key)
	
	If the client is expecting a Query Challenge, it sends a normal IP verify query (See QR2 research)
	Otherwise it sends a normal Query to QR2 with Split packets support
		It could request all keys or a basic query with not player or team queries and just some server queries


When A client request a server:

Request  :: Client (GameSpy 3D) -------> Server Browser (TCP 28910) --------> Query Report 2 Server (UDP 27901)
Response :: Query Report 2 ------> Server Browser (Parse the QR2 data, filter it) -----> Client

The server browser is like a high-level Query Report 2 server, it helps creating a server browser without having to
do everything manually on the Query Report. An interpreter server for QR2.

Get Server rules (Client request) from Server Browser server:
	First two bytes, htons(message length)
	Third byte: 0x01 (Server Info request)
	4 bytes: IP of server
	2 bytes: Port of server

Send Message to the Server:
	First two bytes, htons(message length)
	Third byte: 0x02 (Send Message request)
	4 bytes: IP
	2 bytes: Port

	After this is done, the client sends the message (null terminated) to the Master Server (Server Browser server)

Send NatNeg cookie to server:
	This just do a normal Send message to server function (see above)
	But the data is sended is a natneg request:
		First 6 bytes: NatNeg 6 magic (0xFD, 0xFC, 0x1E, 0x66, 0x6A, 0xB2)
		4 bytes for the cookie (htonl(cookie))


Send MapLoop request:
	First two bytes, htons(message length)
	Third byte: 0x04 (MapLoop request)
	4 bytes: Public IP of server
	2 bytes: Public Port of server

Send PlayerSearch request:
	First two bytes, htons(message length)
	Third byte: 0x05 (PlayerSearch request)
	4 bytes: Search option (htonl(searchOptions))
	4 bytes: Max result
	Null terminated string containing the name


Server Browser responses:
 Main data (Or Server data):
	All data is crypted with GOA (Or Query Report 1 Server) algorithm for the cryptation key that is:
		Secret QR2 key + Challenge + Server Challenge		
		sb_serverlist.c line 797

	Data sended from server, header of crypted data:	
		[Length of Data] [Game Flags] [Data] [Length of Key] [Key Data]
		Byte 0: Length of the data (The length is XORed with 0xEC)
		Byte (Length of data - 1): Key length (Xored with 0xEA)
		The key data is used to decrypt the data
		Byte 1-2: Game flags (Setted by the dedicated server) and used htons
		The data is decrypted with GOA (QR1 Cryptation)

	Fixed Header (First 6 bytes of decrypted data):
		[Public IP] [Default port]
		PublicIP of the client requesting: 4 bytes
		Default port of the client requesting: 2 bytes (if it's 0xFFFF then there was an error)
		
	Error Data: It's contained after the fixed header to the end, null terminated
	Data:
		[Key List] [Unique Value List] [Server list]

	Key List:
		[Length of keys] [KeyInfo] [KeyInfo 2] [...]
		Length of keys: One byte (Max 255 Key infos)
	Key Info:
		[Key length] [Key Name] [Key Type]
		Key length: One byte
		Key name: Null terminated at the end

		Types of keys:
			0x01: KeyInfo byte (value length is 1)
			0x02: KeyInfo short (value length is 2)
			0x00: KeyInfo string
				The first byte is the index, if it's 0xFF then it's a null terminated string
				otherwise we already have the length when we parsed the keys


	Unique Value List:
		[Length of unique values] [Unique value] [Unique Value 2] [....]
		Length of uvalues: One byte (Max 255 unique values)
		Unique value: Null terminated string

	
	Server list:
		[Server Info] [Server Info 2] [...] [Last Server Info]

	Server Info:
		[Flags] [IP] [Port (Optional)] [Server Data (Optional)]
		Flags: One byte, if bit 5 of flags is setted (flags | 16), then the server does not use a default game port
		So, after the IP, The port data will be setted
		IP: 4 bytes containing the IP
		Port: 2 bytes

	Server Data:
		[Private IP] [Private Port] [ICMP IP] [KeyInfo...]
		If bit 2 of flags is setted, then we have the Private IP of the server
		The private IP length is 4
		
		If bit 6 is setted, the server uses a custom private port (not the default one)
		Private port length is 2
		
		If bit 4 is setted, the server have an ICMP server used
		ICMP IP length is 4

		If bit 7 is seteted, the server have some custom keys
		The length was setted when we where parsing the Key List data


		If bit 8 is setted, then we have the game full rules
			All the strings inside the full game rules are null terminated
			[Rule 1] [Rule 2] [...]


 Second data sended: AdHoc data (After the server/main data)
	This data is not crypted

	The first two byes is the message length (then htohs)
	The message can be at maximum 4096.
	
	The third byte is the message type
		Type 1: Push keys
			Add some keys to the server browser client
			The first character is the number of keys (max 255 keys)
			
			The keys follows the structure of KeyInfo

		Type 2: Server message
			Works the same as Server Info

		Type 3: Keepalive message
			All data the server sends it's replied back
		
		Type 4: Delete server
			[Server IP] [Server Port]
			Server IP: 4 bytes
			Server Port: 2 bytes (NOT OPTIONAL)

		Type 5: Maploop (Used when a new map needs to be selected)
			[Server IP] [Server Port] [Time] [Map Count] [Map Data] [Map Data 2...] [...]
			Server IP: 4 bytes
			Server Port: 2 bytes (NOT OPTIONAL)
			Time: 4 bytes (time_t)ntohl(time) rapresentation
			Map Count: One byte telling the number of maps avaiable
			Map Data: Null terminated string
		
		Type 6: Player Search
			[Is Final] [Result Count] [PlayerSearch Data] [PlayerSearch Data 2] [...]
			Is Final: 1 byte, when setted to 1, means the research is finished
				When setted to 0, the client have to expect another Type 6 adhoc packet
			Result Count: 1 byte telling the numbers of result that the playersearch produced

			PlayerSearch Data:
				[Nickname] [IP] [Port] [LastSeen] [Game name]
				Nickname: Null terminated string
				IP: 4 bytes
				Port: 2 bytes (not optional)
				Last Seen: 4 bytes, (time_t)ntohl(lastSeen)
				Game name: A null terminated string
			

Get LAN server list:
	Client binds a socket that will be used for communicating with QR2 (Also multihomed support)
	Client sends a QR2 query request with ID 0x02 and 4 extra bytes (Called echo request) to Server Browser
	
	The QR2 socket is a broadcast socket

When you create a  dedicated server in your lan, by using Query Report 2, GameSpy SB SDK discovers all
dedicated servers opened in your network, if the dedicated servers reply the QR2 Echo Packet

---------------------------------------------------- Master Server: ICMP -----------------------------

Discovered with the SDK, we know that ICMP support can be disabled.
It is confirmed to be used in platforms like PlayStation2.

What server to connect?
 - If the Server (in the serverbrowser ServerData) define a custom ICMP IP, then connect to that
 - Otherwise, connect to the Public IP of the server

Everything looks the same as ServerBrowsing reverse, the different seems to be that
we can parse data not only from the Query socket (UDP) but from the ICMP socket

Platforms that doesn't use ICMP:
 - Linux or any other Unix based distribution (like FreeBSD)
 - MacOSX
 - iPhone
 - Nintendo DS
 - Nintendo Wii

The data follows a usual ICMP protocol: https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol
Look at sb/sb_internal.h for more information about SBICMPHeader.


---------------------------------------------------- Master Server Avaiability ---------------

IP: gamename.avaiable.gamespy.com
Port: 27900

Client SDK conterpart: common/gsAvaiable.c

This part is used to check if the GameSpy service for that specific game is avaiable.
A game that does not support gamespy anymore should return the not avaiable status.
This part is also used to check if the GameSpy service is online or offline.

The data is unencrypted and sended with a char buffer,
each data is filled inside the char buffer

Packet initialization: (Imagine something as char buffer[256])
buffer location 0: packet type (0x09)
buffer location 1-4: 0x00 for all 4
buffer location 5-X: The game name (the length is used for determinate the gamename string length) with null terminator

Response:
NOTE: The length of a response packet must be greater than 6!
The first 3 bytes MUST BE 0xFE, 0xFD and 0x09 (Header)

The next 4 bytes rapresents an integer
the 4 bytes will be byteshifted into one integer.

This integer rapresents the status of the server.

If the first bit is active (status & 1), then the server IS NOT AVAIABLE (GameSpy offline)

If the second bit is active (and not the first, status & 2), then the server IS TEMPORARILY OFFLINE
like a maintenance of the server

If bit 1 and bit 2 are not active (status & 1 < 1 && status & 2 < 1), then the server is online.

---------------------------------------------------- Game Patching ---------------------

GameSpy allowed games to check a game version and report the updates.

Client SDK counterpart: PT\ptMain.c

Patch checking:
The game connects to motd.gamespy.com with port 80.

This exchange works like a normal HTTP page, by fact GHTTP SDK is being used.

The request is:
GET /motd/vercheck.asp

This page is NOT CONTROLLED by a master server, rather the page was programmed with ASP
language and used ISS server as a backend.

The page arguments are the following
productid= the ID of the game
lockout= Unknown usage, it fills a mandatory flag if it's setted to 1
versionuniqueid= An unique identificator of the game (a string)
distid= The distribution channel (identify multiple server for downloading the patch, like EU or NA server)
gamename= The name of the game

A complete request to the page (it could also work in a browser)
GET http://motd.gamespy.com:80/motd/vercheck.asp?productid=1&versionuniqueid=1000&distid=1&gamename=TEST
(The data is random, just used to show the complete page query)

Response of the check patch works like the Presence Server (using the '\')
The response is actually the page content.

newver: the new unique version id
lockout: a mandatory flag?
fpfileid: The file id to download in case a new version is found (fp = fileplanet, used for that in the beginning)
newvername: The name of the new patch (like version 1.1)
dlurl: The URL that the patch will be downloaded

The HTTP SDK will be used to process the file download

---------------------------------------- Game Tracking -----------------------

Client SDK counterpart: PT\ptMain.c (Patching & Tracking SDK)

The client will send an HTTP GET request (like patching) to the following IP: motd.gamespy.com

Request: http://motd.gamespy.com/motd/motd.asp?userid=1&productid=1&uniqueversionid=Test Program 1.0&
distid=0&uniqueid=0&gamename=TEST

NOTE: motd.gamespy.com/motd/motd.asp could be changed!

UserID: the id of the user that will be tracked
ProductID: ID of the product
UniqueVersionID: Unique identifier of the version
DistID: Distribution channel
UniqueID: MAC Address of the Computer/Console that runs the program
GameName: The game name

If any error happens when reading the file, it means that the tracking failed.
Otherwise, the tracking will be succeeded (if it can retrive the file, no matter the content of it)

------------------------------------ Master Server Patching: Downloading files from FilePlanet ----------------

HTTP Request to:
GET http://www.fileplanet.com/dlfileraw.asp?file=3958299&gamename=TEST

file: The file ID, we recive that from "fpfileid"
gamename: the game name


---------------------------------------------- Peer SDK --------------------------------------

Peer is used for communicating between a group of peers.

For example:
 When you make a new lobby for your friends, Peer module will be used to create the lobby
  and handle the communication between you (the lobby master) and all the people logged in
  your lobby (which are the PEERs)

Peer handle the following things:
 Auto matchmaking between the peers in your lobby
 CD-KEY verification for your peers
 Pinging between the peers
 Lobby and Chat handling for your peers

The peer module USES PeerChat for doing this communication.

Each peer does have an unique ID for identifying it.

By fact a lobby in GameSpy MEANS a new chat channel (the IRC Chat channel we all know from PeerChat)

SO inviting in a lobby is basicly inviting a client to an IRC chat.

The lobby name is the IRC chat topic.

For more information on how the communication between PeerChat server and client,
please refeer to the PeerChat research document.


----------------------------------- Game statistics ---------------------------

IP: gamestats.gamespy.com : 29920

gamename.gamestats.gamespy.com => TARGET IP the client connects
Protocol: TCP

Reference: gstats/gstats.c

The server sends a challenge like GameSpy Connection Manager.

Challenge: (38 bytes long)
  The challenge is decoded with Encryption Type 1

Algorithm of decoding (as found in line 127):
  XOR each character of the buffer with the encode string you passed.
  If the encode string is smaller than the buffer, the encode string is resetted
  to it's initial position

  Example: encode string ABCD buffer: 12345678
  1 XOR A
  2 XOR B
  3 XOR C
  4 XOR D

  Encode buffer is resetted to it's initial position.

  5 XOR A
  6 XOR B
  7 XOR C
  8 XOR D

Encode 1: GameSpy3D
Encode 2: Industries 
Encode 3: ProjectAphex

How a connection to the statistics server is initialized:
1. The server sends, after the client is connected, this data:
 (Look at GameSpy presence protocol for more information, as it follows the same):
\challenge\<challenge>\

NOTE: This data must exist on the input data, but we don't know (since it's not checked)
if the server sends any other data
NOTE 2: This data is encrypted with Encode 1
NOTE 3: The \final\ is checked as usual.

2. The client response is the following:
\auth\gamename\<gamename>\response\<response data>\port\<client port>\id\1\final\

Client port is a free port on the client PC for unknown usage.
Gamename is the usual game name
Response data is an MD5 of the following string:
  CRC32 of the challenge that the server sends and the Gamespy CD secret key

  The Gamespy CD secret key is setted by the client and could (or could not be)
  unique.

3. The server sends the following data:
\sesskey\<session key>\

NOTE: the data have the same issue as before
NOTE 2: This data is encrypted with Encode 1

4. The client tries to send a local file that contains the current or new statics (saved inside a file that the developer
of the game can specify) to be sended to the server.

Statistics file format (readed as a binary file):
  Each data is composed by a request that will be sended to the server.
  Something like \custom_data\1\final\. THERE IS THE FINAL\ which tells the server where to end like an usual GPSP request

  Each line is composed by (example proof of concept structure)
  struct Line {
    int32_t check_crc;
    int32_t length;
    void* data;
  }

  1. The client reads the complete size of the file and creates a buffer (called allData in the SDK) with the length of the file + 2 (ftell(fp) + 2)
  2. The client reads the content of the line
    A. The first data readed is the CRC32 check, which is used to check if the line data is corrupted.
    B. The second data readed is the length, which is encrypted with a XOR of 0x70F33A5F (NOTE: In the SDK this is a define, so it could be different on other games) 
    C. The data is readed, the length is used to read the data.
    D. The readed data is decoded with Encryption type 2 (See upper for more information)
    E. A CRC32 of the unencrypted data is calculated and verified if it's the same CRC32 as the Check CRC32 readed before.
    F. The unecnrypted data is encrypted with Encryption type 1, ready to be sended to the server.
    G. The encrypted type1 data is appended to the buffer (allData)
3. After all lines are readed (reached a read error or EOF), the data is sended to the server.

Login to authentication server:
  There are 3 ways of authenting:
    1. Using Player ID
    2. Using CD-KEY
    3. Using AuthToken and the partner ID (used in games like Mario Kart DS)

  Client sends this data to the server (different for each method):
   Method 1: \authp\\pid\<profile ID>\resp\<response data>\lid\<local id>\final\
   Method 2: \authp\\nick\<user nickname>\keyhash\<key hash of the CD-KEY>\resp\<response data>\lid\<local id>\final\
   Method 3: \authp\\authtoken\<auth token>\resp\<response data>\lid\<local id>\final\

  Local ID and Profile ID: setted by the game
  Local ID: game-specific reference number for this player, used to identify what player is in the game
  he is currently playing

  Authentication Response data (different from the last one, and different for each authentication method):
   Method 1: MD5 of password and a generated challenge (see below).
   Method 2: MD5 of cd-key and a generated challenge (see below).
   Method 3: MD5 of partner challenge and a generated challenge (see below).

  Generation of the challenge:
    Create a string with max length 8 bytes
    Convert Connetion ID XORed with 0x38F371E6 (the result is an integer) to hexadecial and copy it to the challenge string.
    NOTE: The format is %08x (sprintf(challenge_string, "%08x", connID ^ CHALLENGE_XOR)), so if the hexadecimal data is smaller that 8, 
      extra 0 will be added at the beginning of the number until all the 8 bytes challenge string is filled up.

    Then, the string will be masked by doing the following algorithm (for each character in the string):
      The current character of the string will be added by 17 (since it's character is an integer) and add the current position of the character that we are encrypting (from 0 to 7)

    NOTE2: The XOR is a define on the SDK, so it could be different on other games.
  Server sends the following data:
    \\pauthr\\<player id>\\lid\\<local id>\\errmsg\\<any error message>\\final\\

    If the authentication failed, the player id is setted to any number lesser than 1 (Like -1) and errmsg is filled up with the
    error message at the authentication.

Getting the data from statistic server (also known as Persist Data):

There are 4 types of persistent data stored for each player:
pd_private_rw (0): Readable only by the authenticated client it belongs to, set by the authenticated client it belongs to
pd_private_ro (1): Readable only by the authenticated client it belongs to, can only by set on the server
pd_public_rw (2): Readable by any client, set by the authenicated client is belongs to
pd_public_ro (3): Readable by any client, can only be set on the server

1. Client sends the following data to the server:
\getpd\\pid\<player id>\ptype\<see above>\dindex\<data index>\keys\<data to get>\lid\<local id>\final\

Keys are used when you want to get multiple data at once.
For example: \clan\color\homepage\. (Each key is delimited by a \)
NOTE: In the request, since '\' is already reserved by the protocol (see GPCM protocol), the client
 converts the '\' from the keys to '\x1'

Modified data: A time value to limit the request for data. Data will only be returned if it has been
	modified since the time provided. If data has not been modified since that time, the callback will be
	called with a success value that indicates it is unmodified.
	Note: modification time is tracked for the given profileid/index, not on a per-persisttype or per-key basis

If the developer want to enable modified data, the request of the client will also contain:
\mod\<time_t integer rapresentation of the modificated since value>

2. Server sends teh following response:
\getpdr\<1 if success or 0 if failed>\lid\<local id>\mod\<time_t rapresention of the last time the data was modified>\length\<length of the data>\data\<the data will be processed by the client>\final\

Getting the profile id from a cd-key login

1. Client sends
\getpid\\nick\<nickname>\keyhash\<CD-KEY hash>\lid\<local id>\final\

2. Server reponses
\getpidr\<pid>\lid\<local id>

------------------------------------ Auth service (aka login with http) ---------------------------

You can login with a SOAP XML Web Service, a web application is hosted by GameSpy.

Domain: gamename.auth.pubsvs.gamespy.com/AuthService/AuthService.asmx (ASP.NET Webservice)

First, the service avaiability is checked as usual.


------------------------------------- SAKE ---------------------------------------

SAKE is a small webserver used to storage some data from the client.
This is a normal HTTP server with a SOAP XML application hosted in it.

Domain: gamename.sake.gamespy.com/SakeStorageServer/StorageServer.asmx (ASP.NET Webservice)

First, the service avaiability is checked as usual.

Second, you login normally with GPSP (No firewall and blocking)

A SAKE profile contains:
  The game name
  The game ID
  The game secret key
  The profile ID
  The profile login ticket

A normal SAKE XML request:
<?xml version="1.0" encoding="UTF-8"?>
<SOAP-ENV:Envelope xmlns:

----------------------------------- Chat server research -----------------------

PeerChat is AN IRC SERVER!
See this RFC for more information on how an IRC server works:
https://tools.ietf.org/html/rfc2813
https://tools.ietf.org/html/rfc2812
https://tools.ietf.org/html/rfc1459

There are two ways of connecting:

1. Non secure connections
2. Secure connection


A non secure connections is a direct connection to the IRC server, much like a normal
IRC client.

But GameSpy does, however, creates a secure connections when a game communicates to the
server, which is used to encrypt the data between the IRC server and the game:

This document will follow the RFC2813 for describing the commands:


Command: LOGINPREAUTH
Parameters: <authtoken> <partnerchallenge>

The LOGINPREAUTH command is sended before logging into a server.

The partner challenge is a special challenge used to indentify the 3rd party company or service
that uses GameSpy (An example of 3rd party service could be Nintendo Wifi Connection)

Example: LOGINPREAUTH GEFJEIAFJ3H84589UFJHEFH38 5820852003


Command: LOGIN

The login should corrispond to the GPCM login, by fact you can login with an Auth token (PREAUTH)
or a normal login

Parameters for normal login: <namespaceID> * <passwordHash> :<profilenick> <email>
or
Parameters for uniquenick login: <namespaceID> <uniqueNick> <passwordHash>

PasswordHash is an MD5 of the password.
NamespaceID is the namespace ID as shown in GPSP

Normal login example: LOGIN 0 * KFEOGJMIASNEFNIAEJFEIF :Arves100 arves100@gmail.com
Uniquenick login example: LOGIN 0 Arves100 KFEOGJMIASNEFNIAEJFEIF

Reply for LOGIN or LOGINPREAUTH if the login succeeded:
:s 707 <userID> <profileID>
Reply for LOGIN or LOGINPREAUTH if the login fails:
:s 708
Reply for LOGIN or LOGINPREAUTH if nickname does not exist:
:s 401
Reply if the nickname is already logged in:
:s 433

Command: USRIP (Same as WHOIS)

Gets the user id of the current connection

Example: USRIP

Reply: :s <encrypted IP>|<profileID>

see https://aluigi.altervista.org/papers/peerchat_ip.zip for the algorithm of encrypting.

Command: REGISTERNICK
Parameter: <namespaceID> <uniqueNick> <cdkey>

This command registers the unique nickname

Example: REGISTERNICK 0 Arves100 FEJI-JTIE-FEIF-FJIE


Command: MODE
Parameter: <nickname> +/-q

NOTE: This command is an extension of the original MODE command from IRC

Enable or disable quiet mode: if +q is sended then quiet mode is enable,
if -q is sended then quiet mode is disabled


Example: MODE Arves100 +q


Command: CDKEY
Parameter: <cdkey>

Sends the CDkey of the game

Example: CDKEY FEJI-JTIE-FEIF-FJIE


Command: PRIVMSG

NOTE: This extends the PRIVMSG command of IRC by adding an action command, which can be
used to specify an action like "Join this game"

Action message parameter: <receiver> :\001ACTION <message>\001

Example: PRIVMSG Arves100 :\001ACTION JOIN THIS\001

Command: ATM
Parameter: <channel> <message>
Reply: :s ATM <nickname> <message>

It should be a type of message


Command: UTM
Parameter: <channel> <message>
Reply: :s UTM <nickname> <messag

It should be a type of message

Command: CRYPT
Parameter: DES versionID GameName
Example: CRYPT DES 1 Capricorn

This command gets some random crypting keys from the server

Reply: :s 705 <clientRandomKey> <serverRandomKey>

The keys have a length of 16 bytes each.
It presumably used the algorithm DES to encrypt the connection, and perhaps different
algorithms where supported

Generic Error: :s 461 <errorMsg>
